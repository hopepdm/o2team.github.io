{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Wed, 27 Dec 2017 03:20:35 GMT","lastBuildDate":"Tue, 02 Jan 2018 08:55:33 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"H5游戏开发：游戏引擎入门推荐","link":"https://aotu.io/notes/2017/12/27/h5-game-engine-recommend/","description":"前言很多刚刚接触到游戏开发，准备大展拳脚的小鲜肉们，往往在技术选型这第一关就栽了跟头。毕竟网络上的游戏引擎良莠不齐，官网上相关资料也比较少，而选择一个适合的游戏引擎是一个项目最基础，也是很核心的一部分。试想一下，在游戏开发进行到中后期的时候，才发现项目引入的游戏引擎与需求相悖，这时候不管是重新做一些修修补补的工作或者更换游戏引擎，这都是相当耗费人力物力的一件事。为了避免这种情况的出现，在前期选择适合项目需求的游戏引擎显得尤为重要。接下来我们来聊一聊如何去选择适合项目的 JS 游戏引擎。 游戏场景分类在刚接到游戏需求时，我们可以从以下几个方面进行考量，分析出游戏需求场景所属，从而作为我们选择游戏引擎的依据。 游戏效果呈现方式（ 2D ？ 3D ？ VR ？）这与游戏引擎能够支持的渲染方式直接挂钩。现在的 H5 游戏渲染方式一般有 2D 渲染、3D 渲染、VR 渲染三种。而 2D 渲染一般也有三种：Dom 渲染、Canvas 渲染、WebGL 渲染。Dom 由于性能原因，一般只适合做一些动画效果较少，交互较少的小游戏，本文主要针对 Canvas 和 WebGL 展开介绍。一般来说，对于 2D 小游戏来说，Canvas 渲染已经足够。然而 Canvas 渲染由于底层封装层次多，不足以支撑起大型游戏的性能要求，因此大型游戏最好选择 WebGL 渲染或者浏览器内嵌 Runtime 。 游戏复杂度这与游戏引擎能够支持的功能，提供的API，性能等方面关系比较大。 游戏引擎推荐笔者从业界较流行的一些框架，进行以下几个方面对比，希望能从客观数据上给大家的技术选型带来建议和参考。 引擎支持的渲染方式 github上的 star 数 更新时间 文档详细度 周边产品 2D，3D，VR 都支持的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注EgretYESYESYESYES2k（最新更新2017.12）▪ 有中文文档▪ 例子充足▪ 社区活跃游戏开发过程中的每个环节基本都有工具支撑。不仅仅提供了一个基于HTML5技术的游戏引擎，更是提供了原生打包工具和众多周边产品LayaAirYESYES（优先）YESYES0.7k（最新更新2017.12）▪ 有中文文档▪ 例子充足▪ 社区活跃提供开发工具和可视化编辑器支持2D、3D、VR，能开发超大游戏，forgame的醉西游，腾讯的QQ农场，乐动卓越的浪漫h5这些大作就是用它开发 Egret Egret 周边产品 白鹭引擎是企业级游戏引擎，有团队维护。Egret 在工作流的支持上做的是比较好的，从 Wing 的代码编写，到 ResDepot 和 TextureMerger 的资源整合，再到 Inspector 调试，最后到原生打包（支持 APP 打包），游戏开发过程中的每个环节基本都有工具支撑。官网上的示例，教程也是比较多。值得一提的是，今年5月白鹭引擎支持了 WebAssembly ，这对于性能的提升又是一大里程碑。 LayaAir在渲染模式上，LayaAir 支持 Canvas 和 WebGL 两种方式；在工具流的支持程度上，主要是提供了 LayaAir IDE。LayaAir IDE 包括代码模式与设计模式，支持代码开发与美术设计分离，内置了 SWF 转换、图集打包、JS 压缩与加密、APP 打包、Flash 发布等实用功能。 下图是主要支持2D游戏的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注Pixi.jsYESYESNONO16.8k(最新更新2017.12)▪ 英文文档▪ 例子充足▪ 英文社区无依赖于canvas的WebGL渲染器PhaserYESYESNONO16.9k（最新更2017.07）▪ 英文文档▪ 例子充足▪ 英文社区提供在线编辑器Phaser SandboxCreateJsYESYESNONO6.5k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 有博客无官方推荐TweenJS，SoundJS，PreloadJS配合使用HiloYESYESYES(Hilo3D)NO4.2k（最新更新2017.12）▪ 有中文文档▪ 例子充足提供资源下载和管理工具阿里巴巴集团推出，适合开发营销小游戏，以Chipmunk为2D物理引擎，与主流物理引擎兼容Cocos2d-xYESYESNONO11.2k（最新更新2017.12）▪ 有中文文档▪ js例子不多，c++例子较多▪ 社区活跃Cocos Creator编辑器，打包工具等提供的功能相当完整lufylegend.jsYESNONONO0.4k（最新更新2016.03）▪ 有中文文档▪ 社区活跃无仿ActionScript3.0的语法，支持Google Chrome，Firefox，Opera，IE9，IOS，Android等多种热门环境，可以配合Box2dWeb制作物理游戏，内置了LTweenLite缓动类等 Pixi.js一般来说，WebGL 的渲染速度都会比 Canvas 快，这是由俩者的绘制路径决定的。Pixi 最大的特点在于，Pixi 具有完整的 WebGL 支持，却并不要求开发者掌握 WebGL 的相关知识，并在需要时无缝地回退到 Canvas 。相较于很多同类产品，它的渲染能力是比较强大的。然而，Pixi 也有不足的地方，Pixi 对于动画的支持是比较缺乏的，在实际开发中，常常需要引进额外的动画库，如 GSAP。 PhaserPhaser 在渲染方面直接封装了 Pixi；架构方面，Phaser 内嵌了3个物理引擎（Arcade Physics、Ninja、p2.js），提供粒子系统、动画、预下载和设备适配方案；兼容性方面，Phaser 的焦点是放在移动端浏览器上的；API 方面，Phaser 能实现丰富的游戏功能，适合复杂度高的游戏开发。 CreateJS CreateJs 周边产品 CreateJS 官方提供了 TweenJS 支持动画开发，同时通过 SoundJS 和 PreLoadJS 提供了音频和预下载的支持，对于 H5 游戏基础功能的支持是足够的。在兼容性方面，CreateJS 支持 PC 端和移动端几乎所有的浏览器。此外，CreateJS 还支持用 flash CC 开发导出由 CreateJS 渲染的 H5 游戏。 HiloHilo 是阿里团队推出的一个开源项目，支持模块化开发，同时提供了多种模块范式的包装版本和跨终端解决方案，适合用来开发营销小游戏。其体积也是比较轻量的，只有70kb左右。Hilo 支持 DOM 渲染，Canvas 渲染和 WebGL 渲染，同时集成了 Hilo Audio， Hilo Preload。其后推出的 Hilo 3D 也是其亮点之一。 Cocos2d-xCocos2d-x 是业界比较老牌的游戏引擎了，同时支持 C++ ，Lua 和 JavaScript 三种开发语言，官方用例来看更倾向于 C++ 开发，适合做一些中大型游戏开发。Cocos2d-x 提供 Cocos Creator 游戏开发工具，组件化，脚本化，数据驱动，跨平台发布。 lufylegend.jslufylegend.js 的最新更新是在16年，不过其社区还是十分活跃的，如果遇到什么开发问题，可以很方便地在社区上找到解决的方案。lufylegend.js 可以支持基础的游戏功能，但是其可拓展性不是很强。 主要支持3D游戏的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注Three.jsNONOYES（倾向）NO37.6k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 英文社区无默认Ammo.js为默认物理引擎，基于JavaScript语言的3D库，耗性能，加载慢，效果一般PlayCanvasNONOYESYES3k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 英文社区提供了在线编辑器，发布托管等教程较为详细，入门快 Three.js Three.js 示例案例 相信对于很多有关注 3D 游戏的开发者来说，Three.js 早已经耳熟能详了。实际上，Three.js 官方定位并不是游戏引擎，而是一个 JS 3D 库。Three.js 更倾向于展示型的视觉呈现，比较少直接拿 Three.js 来开发 H5 游戏。渲染环境上，Three.js 支持 WebGL 和 CSS3D 两种渲染模式。 PlayCanvas从渲染支持程度来看，PlayCanvas 不仅支持 3D WebGL渲染，同时保持到 VR 的支持，拥有比较好的拓展性。在工具流的支持上，提供了在线编辑器和发布托管等服务。从官方教程上看，教程也是比较详细的。 结语现在市场上的 H5游戏引擎很多，很难去直接定义哪个引擎的好坏，只能说每个引擎都有自己的特性，在某方面跟项目的契合程度比较高，笔者根据现在市场上比较热门的几大引擎做了几点比较，希望能给刚入门的你做技术选型的时候有一点帮助，找到适合项目的引擎，更快、更准、更高效率地完成项目需求。 感谢各位耐心读完，希望能有所收获，有考虑不足的地方欢迎留言指出。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料目前有哪些比较成熟的 HTML5 游戏引擎？ HTML5游戏引擎深度测评 现在 TypeScript 的生态如何？","pubDate":"Wed, 27 Dec 2017 03:20:35 GMT","guid":"https://aotu.io/notes/2017/12/27/h5-game-engine-recommend/","category":"H5游戏开发"},{"title":"GraphQL 使用介绍","link":"https://aotu.io/notes/2017/12/15/graphql-use/","description":"GraphQL 是 Fackbook 的一个开源项目，它定义了一种查询语言，用于描述客户端与服务端交互时的数据模型和功能，相比 RESTful API 主要有以下特点： 根据需要返回数据 一个请求获取多个资源 提供内省系统 这使得客户端的功能得到了加强，特别是在查询数据方面。 下面我们\u0006从使用的角度来介绍一下。 相关概念在使用 GraphQL 之前，先介绍几个相关概念，便于理解使用。 Operations GraphQL 服务提供的操作一般有：query、mutation。query 可以理解为 RESTful API 中的 GET 的请求。mutation 可以理解为 RESTful API 中的 POST、PUT、DELETE 之类的请求。 Types 定义了 GraphQL 服务支持的类型，例如： 12345678type User &#123; id: ID name: String&#125;type Query &#123; user: User&#125; 定义了 User 类型和包含的字段以及字段的类型；定义 Query 返回一个 User 类型的 user，Query 也是一种类型。 Scalar types 标量类型。GraphQL 默认提供的标量类型有：Int、Float、String、Boolean、ID，也可以实现自定义的标量类型，如：Date。 标量类型有什么用呢？返回数据的字段必须是标量类型。例如我们想返回一个 user： 123query &#123; user // 报错&#125; 上面这样是会报错的，因为 user 不是标量类型，需要改成 123456query &#123; user &#123; id name &#125;&#125; 指定返回 user 的 id 和 name，这两个字段都是标量类型，就可以正确返回了。 开始使用如果看完上面的介绍，心中有很多疑问，没关系，我们现在以 GitHub GraphQL API 为例，来实际使用一下。打开 https://developer.github.com/v4/explorer/，然后登录，会看到一个这样的界面 这是 GraphQL 提供的开发工具 GraphiQL，可以检查 GraphQL 的语法，发送 GraphQL 的请求，还提供文档查询功能。在开始使用之前先介绍一下文档查询功能。点击右上角的 &lt; Docs 并可以看到 上面的 ROOT TYPES 表示最顶层支持的类型，只有两个 Query 和 Mutation。点击 Query，可以看到该类型包含的字段。仔细看，会发现这些字段的值又都是类型。 往下滚动，找到 user(login: String!): User，点击 User 终于找到一个标量类型的字段 bio: String，按照之前说法，我们是可以查询这个字段，写出如下的查询语言： 12345&#123; user &#123; bio &#125;&#125; 准备执行时，会看到 user 下方有条红线，鼠标放上去 提示 user 必须指定一个 login 的参数，再回头看文档中该字段的描述 user(login: String!): User，是不是就可以理解了，(login: ) 表示该字段接受一个 login 参数，为 String 类型，! 表示是必须的。 将查询语言改成： 12345&#123; user(login: \"booxood\") &#123; bio &#125;&#125; 再执行，并得到了我们预期指定的结果 1234567&#123; \"data\": &#123; \"user\": &#123; \"bio\": \"Happy coding &amp; Happy life\" &#125; &#125;&#125; 现在是不是有点理解这种查询语言了。下面我们再以【 Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件】中的两个需求为例 展示某个 Issue 的评论和评论上的点赞数据 1234567891011121314151617181920query &#123; repository(owner: \"gitalk\", name: \"gitalk\") &#123; issue(number: 1) &#123; comments(last: 10) &#123; totalCount nodes &#123; author &#123; login avatarUrl &#125; body reactions(first: 100, content: HEART) &#123; totalCount viewerHasReacted &#125; &#125; &#125; &#125; &#125;&#125; 先通过 repository(owner: &quot;gitalk&quot;, name: &quot;gitalk&quot;) 找到 repository，再通过 issue(number: 1) 指定 issue，然后 comments(last: 10) 表示从后面取 10 条 comments，同时获取评论的 body 和 评论的 reactions(first: 100, content: HEART) 以及 reactions 的相关信息。 添加或取消某个评论上的点赞 添加 1234567mutation &#123; addReaction(input: &#123;subjectId: \"MDEyOklzc3VlQ29tbWVudDMxNTQxOTc2NQ==\", content: HEART&#125;) &#123; reaction &#123; content &#125; &#125;&#125; 取消 1234567mutation &#123; removeReaction(input: &#123;subjectId: \"MDEyOklzc3VlQ29tbWVudDMxNTQxOTc2NQ==\", content: HEART&#125;) &#123; reaction &#123; content &#125; &#125;&#125; 之前的都是查询，这两个是 mutation，分别调用了 addReaction 和 removeReaction。可以在从文档的 ROOT TYPE 上选择 Mutation 查看支持的所有 mutation。 以上主要介绍了 GraphQL 的基本使用，具体更多内容可以查看 GraphQL 提供的教程。","pubDate":"Fri, 15 Dec 2017 10:27:36 GMT","guid":"https://aotu.io/notes/2017/12/15/graphql-use/","category":"Web开发"},{"title":"H5游戏开发：指尖大冒险","link":"https://aotu.io/notes/2017/11/28/h5_game_jumping/","description":"在今年八月中旬，《指尖大冒险》SNS 游戏诞生，其具体的玩法是通过点击屏幕左右区域来控制机器人的前进方向进行跳跃，而阶梯是无穷尽的，若遇到障碍物或者是踩空、或者机器人脚下的阶砖陨落，那么游戏失败。 笔者对游戏进行了简化改造，可通过扫下面二维码进行体验。 《指尖大冒险》SNS 游戏简化版 该游戏可以被划分为三个层次，分别为景物层、阶梯层、背景层，如下图所示。 《指尖大冒险》游戏的层次划分 整个游戏主要围绕着这三个层次进行开发： 景物层：负责两侧树叶装饰的渲染，实现其无限循环滑动的动画效果。 阶梯层：负责阶梯和机器人的渲染，实现阶梯的随机生成与自动掉落阶砖、机器人的操控。 背景层：负责背景底色的渲染，对用户点击事件监听与响应，把景物层和阶梯层联动起来。 而本文主要来讲讲以下几点核心的技术内容： 无限循环滑动的实现 随机生成阶梯的实现 自动掉落阶砖的实现 下面，本文逐一进行剖析其开发思路与难点。 一、无限循环滑动的实现景物层负责两侧树叶装饰的渲染，树叶分为左右两部分，紧贴游戏容器的两侧。 在用户点击屏幕操控机器人时，两侧树叶会随着机器人前进的动作反向滑动，来营造出游戏运动的效果。并且，由于该游戏是无穷尽的，因此，需要对两侧树叶实现循环向下滑动的动画效果。 循环场景图设计要求 对于循环滑动的实现，首先要求设计提供可前后无缝衔接的场景图，并且建议其场景图高度或宽度大于游戏容器的高度或宽度，以减少重复绘制的次数。 然后按照以下步骤，我们就可以实现循环滑动： 重复绘制两次场景图，分别在定位游戏容器底部与在相对偏移量为贴图高度的上方位置。 在循环的过程中，两次贴图以相同的偏移量向下滑动。 当贴图遇到刚滑出游戏容器的循环节点时，则对贴图位置进行重置。 无限循环滑动的实现 用伪代码描述如下：12345678910111213141516// 设置循环节点transThreshold = stageHeight;// 获取滑动后的新位置，transY是滑动偏移量lastPosY1 = leafCon1.y + transY; lastPosY2 = leafCon2.y + transY;// 分别进行滑动if leafCon1.y &gt;= transThreshold // 若遇到其循环节点，leafCon1重置位置 then leafCon1.y = lastPosY2 - leafHeight; else leafCon1.y = lastPosY1;if leafCon2.y &gt;= transThreshold // 若遇到其循环节点，leafCon2重置位置 then leafCon2.y = lastPosY1 - leafHeight; else leafCon2.y = lastPosY2; 在实际实现的过程中，再对位置变化过程加入动画进行润色，无限循环滑动的动画效果就出来了。 二、随机生成阶梯的实现随机生成阶梯是游戏的最核心部分。根据游戏的需求，阶梯由「无障碍物的阶砖」和「有障碍物的阶砖」的组成，并且阶梯的生成是随机性。 无障碍阶砖的规律其中，无障碍阶砖组成一条畅通无阻的路径，虽然整个路径的走向是随机性的，但是每个阶砖之间是相对规律的。 因为，在游戏设定里，用户只能通过点击屏幕的左侧或者右侧区域来操控机器人的走向，那么下一个无障碍阶砖必然在当前阶砖的左上方或者右上方。 无障碍路径的生成规律 用 0、1 分别代表左上方和右上方，那么我们就可以建立一个无障碍阶砖集合对应的数组（下面简称无障碍数组），用于记录无障碍阶砖的方向。 而这个数组就是包含 0、1 的随机数数组。例如，如果生成如下阶梯中的无障碍路径，那么对应的随机数数组为 [0, 0, 1, 1, 0, 0, 0, 1, 1, 1]。 无障碍路径对应的 0、1 随机数 障碍阶砖的规律障碍物阶砖也是有规律而言的，如果存在障碍物阶砖，那么它只能出现在当前阶砖的下一个无障碍阶砖的反方向上。 根据游戏需求，障碍物阶砖不一定在邻近的位置上，其相对当前阶砖的距离是一个阶砖的随机倍数，距离范围为 1～3。 障碍阶砖的生成规律 同样地，我们可以用 0、1、2、3 代表其相对距离倍数，0 代表不存在障碍物阶砖，1 代表相对一个阶砖的距离，以此类推。 因此，障碍阶砖集合对应的数组就是包含 0、1、2、3 的随机数数组（下面简称障碍数组）。例如，如果生成如下图中的障碍阶砖，那么对应的随机数数组为 [0, 1, 1, 2, 0, 1, 3, 1, 0, 1]。 障碍阶砖对应的 0、1、2、3 随机数 除此之外，根据游戏需求，障碍物阶砖出现的概率是不均等的，不存在的概率为 50% ，其相对距离越远概率越小，分别为 20%、20%、10%。 利用随机算法生成随机数组根据阶梯的生成规律，我们需要建立两个数组。 对于无障碍数组来说，随机数 0、1 的出现概率是均等的，那么我们只需要利用 Math.random()来实现映射，用伪代码表示如下：1234// 生成随机数i，min &lt;= i &lt; maxfunction getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min) + min);&#125; 12345// 生成指定长度的0、1随机数数组arr = [];for i = 0 to len arr.push(getRandomInt(0,2));return arr; 而对于障碍数组来说，随机数 0、1、2、3 的出现概率分别为：P(0)=50%、P(1)=20%、P(2)=20%、P(3)=10%，是不均等概率的，那么生成无障碍数组的办法便是不适用的。 那如何实现生成这种满足指定非均等概率分布的随机数数组呢？ 我们可以利用概率分布转化的理念，将非均等概率分布转化为均等概率分布来进行处理，做法如下： 建立一个长度为 L 的数组 A ，L 的大小从计算非均等概率的分母的最小公倍数得来。 根据非均等概率分布 P 的情况，对数组空间分配，分配空间长度为 L * Pi ，用来存储记号值 i 。 利用满足均等概率分布的随机办法随机生成随机数 s。 以随机数 s 作为数组 A 下标，可得到满足非均等概率分布 P 的随机数 A[s] ——记号值 i。 我们只要反复执行步骤 4 ，就可得到满足上述非均等概率分布情况的随机数数组——障碍数组。 结合障碍数组生成的需求，其实现步骤如下图所示。 障碍数组值随机生成过程 用伪代码表示如下：1234567891011121314151617181920// 非均等概率分布PiP = [0.5, 0.2, 0.2, 0.1]; // 获取最小公倍数L = getLCM(P); // 建立概率转化数组A = [];l = 0;for i = 0 to P.length k = L * P[i] + l while l &lt; k A[l] = i; l++;// 获取均等概率分布的随机数s = Math.floor(Math.random() * L);// 返回满足非均等概率分布的随机数return A[s]; 对这种做法进行性能分析，其生成随机数的时间复杂度为 O(1) ，但是在初始化数组 A 时可能会出现极端情况，因为其最小公倍数有可能为 100、1000 甚至是达到亿数量级，导致无论是时间上还是空间上占用都极大。 有没有办法可以进行优化这种极端的情况呢？经过研究，笔者了解到 Alias Method 算法可以解决这种情况。 Alias Method 算法有一种最优的实现方式，称为 Vose’s Alias Method ，其做法简化描述如下： 根据概率分布，以概率作为高度构造出一个高度为 1（概率为1）的矩形。 根据构造结果，推导出两个数组 Prob 数组和 Alias 数组。 在 Prob 数组中随机取其中一值 Prob[i] ，与随机生成的随机小数 k，进行比较大小。 若 k &lt;= Prob[i] ，那么输出符合期望概率分布的随机数为 i，否则输出的值是 Alias[i] 。 对障碍阶砖分布概率应用 Vose’s Alias Method 算法的数组推导过程 如果有兴趣了解具体详细的算法过程与实现原理，可以阅读 Keith Schwarz 的文章《Darts, Dice, and Coins》。 根据 Keith Schwarz 对 Vose’s Alias Method 算法的性能分析，该算法在初始化数组时的时间复杂度始终是 O(n) ，而且随机生成的时间复杂度在 O(1) ，空间复杂度也始终是 O(n) 。 两种做法的性能比较（引用 Keith Schwarz 的分析结果) 两种做法对比，明显 Vose’s Alias Method 算法性能更加稳定，更适合非均等概率分布情况复杂，游戏性能要求高的场景。 在 Github 上，@jdiscar 已经对 Vose’s Alias Method 算法进行了很好的实现，你可以到这里学习。 最后，笔者仍选择一开始的做法，而不是 Vose’s Alias Method 算法。因为考虑到在生成障碍数组的游戏需求场景下，其概率是可控的，它并不需要特别考虑概率分布极端的可能性，并且其代码实现难度低、代码量更少。 根据相对定位确定阶砖位置利用随机算法生成无障碍数组和障碍数组后，我们需要在游戏容器上进行绘制阶梯，因此我们需要确定每一块阶砖的位置。 我们知道，每一块无障碍阶砖必然在上一块阶砖的左上方或者右上方，所以，我们对无障碍阶砖的位置计算时可以依据上一块阶砖的位置进行确定。 无障碍阶砖的位置计算推导 如上图推算，除去根据设计稿测量确定第一块阶砖的位置，第n块的无障碍阶砖的位置实际上只需要两个步骤确定： 第 n 块无障碍阶砖的 x 轴位置为上一块阶砖的 x 轴位置偏移半个阶砖的宽度，若是在左上方则向左偏移，反之向右偏移。 而其 y 位置则是上一块阶砖的 y 轴位置向上偏移一个阶砖高度减去 26 像素的高度。 其用伪代码表示如下：123456// stairSerialNum代表的是在无障碍数组存储的随机方向值direction = stairSerialNum ? 1 : -1;// lastPosX、lastPosY代表上一个无障碍阶砖的x、y轴位置tmpStair.x = lastPosX + direction * (stair.width / 2);tmpStair.y = lastPosY - (stair.height - 26); 接着，我们继续根据障碍阶砖的生成规律，进行如下图所示推算。 障碍阶砖的位置计算推导 可以知道，障碍阶砖必然在无障碍阶砖的反方向上，需要进行反方向偏移。同时，若障碍阶砖的位置相距当前阶砖为 n 个阶砖位置，那么 x 轴方向上和 y 轴方向上的偏移量也相应乘以 n 倍。 其用伪代码表示如下：12345678910// 在无障碍阶砖的反方向oppoDirection = stairSerialNum ? -1 : 1;// barrSerialNum代表的是在障碍数组存储的随机相对距离n = barrSerialNum;// x轴方向上和y轴方向上的偏移量相应为n倍if barrSerialNum !== 0 // 0 代表没有 tmpBarr.x = firstPosX + oppoDirection * (stair.width / 2) * n, tmpBarr.y = firstPosY - (stair.height - 26) * n; 至此，阶梯层完成实现随机生成阶梯。 三、自动掉落阶砖的实现当游戏开始时，需要启动一个自动掉落阶砖的定时器，定时执行掉落末端阶砖的处理，同时在任务中检查是否有存在屏幕以外的处理，若有则掉落这些阶砖。 所以，除了机器人碰障碍物、走错方向踩空导致游戏失败外，若机器人脚下的阶砖陨落也将导致游戏失败。 而其处理的难点在于： 如何判断障碍阶砖是相邻的或者是在同一 y 轴方向上呢？ 如何判断阶砖在屏幕以外呢？ 掉落相邻及同一y轴方向上的障碍阶砖对于第一个问题，我们理所当然地想到从底层逻辑上的无障碍数组和障碍数组入手：判断障碍阶砖是否相邻，可以通过同一个下标位置上的障碍数组值是否为1，若为1那么该障碍阶砖与当前末端路径的阶砖相邻。 但是，以此来判断远处的障碍阶砖是否是在同一 y 轴方向上则变得很麻烦，需要对数组进行多次遍历迭代来推算。 而经过对渲染后的阶梯层观察，我们可以直接通过 y 轴位置是否相等来解决，如下图所示。 掉落相邻及同一 y 轴方向上的障碍阶砖 因为不管是来自相邻的，还是同一 y 轴方向上的无障碍阶砖，它们的 y 轴位置值与末端的阶砖是必然相等的，因为在生成的时候使用的是同一个计算公式。 处理的实现用伪代码表示如下：12345678910111213// 记录被掉落阶砖的y轴位置值thisStairY = stair.y; // 掉落该无障碍阶砖stairCon.removeChild(stair);// 掉落同一个y轴位置的障碍阶砖barrArr = barrCon.children;for i in barrArr barr = barrArr[i], thisBarrY = barr.y; if barr.y &gt;= thisStairY // 在同一个y轴位置或者低于 barrCon.removeChild(barr); 掉落屏幕以外的阶砖那对于第二个问题——判断阶砖是否在屏幕以外，是不是也可以通过比较阶砖的 y 轴位置值与屏幕底部y轴位置值的大小来解决呢？ 不是的，通过 y 轴位置来判断反而变得更加复杂。 因为在游戏中，阶梯会在机器人前进完成后会有回移的处理，以保证阶梯始终在屏幕中心呈现给用户。这会导致阶砖的 y 轴位置会发生动态变化，对判断造成影响。 但是我们根据设计稿得出，一屏幕内最多能容纳的无障碍阶砖是 9 个，那么只要把第 10 个以外的无障碍阶砖及其相邻的、同一 y 轴方向上的障碍阶砖一并移除就可以了。 掉落屏幕以外的阶砖 所以，我们把思路从视觉渲染层面再转回底层逻辑层面，通过检测无障碍数组的长度是否大于 9 进行处理即可，用伪代码表示如下：1234567891011// 掉落无障碍阶砖stair = stairArr.shift();stair &amp;&amp; _dropStair(stair);// 阶梯存在数量超过9个以上的部分进行批量掉落if stairArr.length &gt;= 9 num = stairArr.length - 9, arr = stairArr.splice(0, num); for i = 0 to arr.length _dropStair(arr[i]);&#125; 至此，两个难点都得以解决。 后言为什么笔者要选择这几点核心内容来剖析呢？因为这是我们经常在游戏开发中经常会遇到的问题： 怎样处理游戏背景循环？ 有 N 类物件，设第 i 类物件的出现概率为 P(X=i) ，如何实现产生满足这样概率分布的随机变量 X ？ 而且，对于阶梯自动掉落的技术点开发解决，也能够让我们认识到，游戏开发问题的解决可以从视觉层面以及逻辑底层两方面考虑，学会转一个角度思考，从而将问题解决简单化。 这是本文希望能够给大家在游戏开发方面带来一些启发与思考的所在。最后，还是老话，行文仓促，若错漏之处还望指正，若有更好的想法，欢迎留言交流讨论！ 另外，本文同时发布在「H5游戏开发」专栏，如果你对该方面的系列文章感兴趣，欢迎关注我们的专栏。 参考资料 《Darts, Dice, and Coins》","pubDate":"Tue, 28 Nov 2017 00:10:00 GMT","guid":"https://aotu.io/notes/2017/11/28/h5_game_jumping/","category":"H5游戏开发"},{"title":"网页适配 iPhoneX，就是这么简单","link":"https://aotu.io/notes/2017/11/27/iphonex/","description":"前言iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。 笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案分享给大家，希望对大家有所帮助，以下是处理前后效果图： 适配之前需要了解的几个新知识安全区域安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域： 也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。 更详细说明，参考文档：Human Interface Guidelines - iPhoneX viewport-fitiOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容（左图） cover：网页内容完全覆盖可视窗口（右图） auto：默认值，跟 contain 表现一致 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。 更详细说明，参考文档：viewport-fit-descriptor env() 和 constant()iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。 注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。 在这之前，笔者使用的是 constant()，后来，官方文档加了这么一段注释（坑）： The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward. 这就意味着，之前使用的 constant() 在 iOS11.2 之后就不能使用的，但我们还是需要做向后兼容，像这样： 12padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */ 注意：env() 跟 constant() 需要同时存在，而且顺序不能换。 更详细说明，参考文档：Designing Websites for iPhone X 如何适配了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。 第一步：设置网页在可视窗口的布局方式新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：1&lt;meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover\"&gt; 前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。 第二步：页面主体内容限定在安全区域内这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。1234body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 第三步：fixed 元素的适配类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况： 可以通过加内边距 padding 扩展高度：1234&#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 或者通过计算函数 calc 覆盖原来高度：1234&#123; height: calc(60px(假设值) + constant(safe-area-inset-bottom)); height: calc(60px(假设值) + env(safe-area-inset-bottom));&#125; 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。 还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样： 1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 空的颜色块：12345678&#123; position: fixed; bottom: 0; width: 100%; height: constant(safe-area-inset-bottom); height: env(safe-area-inset-bottom); background-color: #fff;&#125; 类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：1234&#123; bottom: calc(50px(假设值) + constant(safe-area-inset-bottom)); bottom: calc(50px(假设值) + env(safe-area-inset-bottom));&#125; 你也可以使用 @supports 隔离兼容样式写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响：123456@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; div &#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); &#125;&#125; 写在最后以上几种方案仅供参考，笔者认为，现阶段适配处理起来是有点折腾，但是至少能解决，具体需要根据页面实际场景，在不影响用户体验与操作的大前提下不断尝试与探索，才能更完美的适配。","pubDate":"Mon, 27 Nov 2017 02:00:00 GMT","guid":"https://aotu.io/notes/2017/11/27/iphonex/","category":"Web开发"},{"title":"H5游戏开发：决胜三分球","link":"https://aotu.io/notes/2017/11/16/basketball/","description":"前言本次是与腾讯手机充值合作推出的活动，用户通过氪金充值话费或者分享来获得更多的投篮机会，根据最终的进球数排名来发放奖品。 用户可以通过滑动拉出一条辅助线，根据辅助线长度和角度的不同将球投出，由于本次活动的开发周期短，在物理特性实现方面使用了物理引擎，所有本文的分享内容是如何结合物理引擎去实现一款投篮小游戏，如下图所示。 准备 此次我使用的游戏引擎是 LayaAir，你也可以根据你的爱好和实际需求选择合适的游戏引擎进行开发，为什么选择该引擎进行开发 ，总的来说有以下几个原因： LayaAir 官方文档、API、示例学习详细、友好，可快速上手 除了支持 2D 开发，同时还支持 3D 和 VR 开发，支持 AS、TS、JS 三种语言开发 在开发者社区中提出的问题，官方能及时有效的回复 提供 IDE 工具，内置功能有打包 APP、骨骼动画转换、图集打包、SWF转换、3D 转换等等 物理引擎方面采用了 Matter.js，篮球、篮网的碰撞弹跳都使用它来实现，当然，还有其他的物理引擎如 planck.js、p2.js 等等，具体没有太深入的了解，Matter.js 相比其他引擎的优势在于： 轻量级，性能不逊色于其他物理引擎 官方文档、Demo 例子非常丰富，配色有爱 API 简单易用，轻松实现弹跳、碰撞、重力、滚动等物理效果 Github Star 数处于其他物理引擎之上，更新频率更高 开始一、初始化游戏引擎首先对 LayaAir 游戏引擎进行初始化设置，Laya.init 创建一个 1334x750 的画布以 WebGL 模式去渲染，渲染模式下有 WebGL 和 Canvas，使用 WebGL 模式下会出现锯齿的问题，使用 Config.isAntialias 抗锯齿可以解决此问题，并且使用引擎中自带的多种屏幕适配 screenMode。 如果你使用的游戏引擎没有提供屏幕适配，欢迎阅读另一位同事所写的文章【H5游戏开发：横屏适配】。 12345678...Config.isAntialias = true; // 抗锯齿Laya.init(1334, 750, Laya.WebGL); // 初始化一个画布，使用 WebGL 渲染，不支持时会自动切换为 CanvasLaya.stage.alignV = 'top'; // 适配垂直对齐方式Laya.stage.alignH = 'middle'; // 适配水平对齐方式Laya.stage.screenMode = this.Stage.SCREEN_HORIZONTAL; // 始终以横屏展示Laya.stage.scaleMode = \"fixedwidth\"; // 宽度不变，高度根据屏幕比例缩放，还有 noscale、exactfit、showall、noborder、full、fixedheight 等适配模式... 二、初始化物理引擎、加入场景然后对 Matter.js 物理引擎进行初始化，Matter.Engine 模块包含了创建和处理引擎的方法，由引擎运行这个世界，engine.world 则包含了用于创建和操作世界的方法，所有的物体都需要加入到这个世界中，Matter.Render 是将实例渲染到 Canvas 中的渲染器。 enableSleeping 是开启刚体处于静止状态时切换为睡眠状态，减少物理运算提升性能，wireframes 关闭用于调试时的线框模式，再使用 LayaAir 提供的 Laya.loading、new Sprite 加载、绘制已简化的场景元素。 1234567891011121314...this.engine;var world;this.engine = Matter.Engine.create(&#123; enableSleeping: true // 开启睡眠&#125;);world = this.engine.world;Matter.Engine.run(this.engine); // Engine 启动var render = LayaRender.create(&#123; engine: this.engine, options: &#123; wireframes: false, background: \"#000\" &#125;&#125;);LayaRender.run(render); // Render 启动... 1234567...// 加入背景、篮架、篮框var bg = new this.Sprite();Laya.stage.addChild(bg);bg.pos(0, 0);bg.loadImage('images/bg.jpg');... 三、画出辅助线，计算长度、角度投球的力度和角度是根据这条辅助线的长短角度去决定的，现在我们加入手势事件 MOUSE_DOWN、MOUSE_MOVE、MOUSE_UP 画出辅助线，通过这条辅助线起点和终点的 X、Y 坐标点再结合两个公式： getRad、getDistance 计算出距离和角度。 1234567...var line = new this.Sprite();Laya.stage.addChild(line);Laya.stage.on(this.Event.MOUSE_DOWN, this, function(e) &#123; ... &#125;);Laya.stage.on(this.Event.MOUSE_MOVE, this, function(e) &#123; ... &#125;);Laya.stage.on(this.Event.MOUSE_UP, this, function(e) &#123; ... &#125;);... 12345678910111213...getRad: function(x1, y1, x2, y2) &#123; // 返回两点之间的角度 var x = x2 - x1; var y = y2 - x2; var Hypotenuse = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)); var angle = x / Hypotenuse; var rad = Math.acos(angle); if (y2 &lt; y1) &#123; rad = -rad; &#125; return rad;&#125;,getDistance: function(x1, y1, x2, y2) &#123; // 计算两点间的距离 return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));&#125;... 四、生成篮球施加力度大致初始了一个简单的场景，只有背景和篮框，接下来是加入投篮。 每次在 MOUSE_UP 事件的时候我们就生成一个圆形的刚体， isStatic: false 我们要移动所以不固定篮球，并且设置 density 密度、restitution 弹性、刚体的背景 sprite 等属性。 将获得的两个值：距离和角度，通过 applyForce 方法给生成的篮球施加一个力，使之投出去。 12345678910111213141516171819...addBall: function(x, y) &#123; var ball = Matter.Bodies.circle(500, 254, 28, &#123; // x, y, 半径 isStatic: false, // 不固定 density: 0.68, // 密度 restitution: 0.8, // 弹性 render: &#123; visible: true, // 开启渲染 sprite: &#123; texture: 'images/ball.png', // 设置为篮球图 xOffset: 28, // x 设置为中心点 yOffset: 28 // y 设置为中心点 &#125; &#125; &#125;);&#125;Matter.Body.applyForce(ball, ball.position, &#123; x: x, y: y &#125;); // 施加力Matter.World.add(this.engine.world, [ball]); // 添加到世界... 五、加入其他刚体、软体现在，已经能顺利的将篮球投出，现在我们还需要加入一个篮球网、篮框、篮架。 通过 Matter.js 加入一些刚体和软体并且赋予物理特性 firction 摩擦力、frictionAir 空气摩擦力等， visible: false 表示是否隐藏，collisionFilter 是过滤碰撞让篮球网之间不产生碰撞。 123456789101112131415161718192021222324252627282930...addBody: function() &#123; var group = Matter.Body.nextGroup(true); var netBody = Matter.Composites.softBody(1067, 164, 6, 4, 0, 0, false, 8.5, &#123; // 篮球网 firction: 1, // 摩擦力 frictionAir: 0.08, // 空气摩擦力 restitution: 0, // 弹性 render: &#123; visible: false &#125;, collisionFilter: &#123; group: group &#125; &#125;, &#123; render: &#123; lineWidth: 2, strokeStyle: \"#fff\" &#125; &#125;); netBody.bodies[0].isStatic = netBody.bodies[5].isStatic = true; // 将篮球网固定起来 var backboard = Matter.Bodies.rectangle(1208, 120, 50, 136, &#123; // 篮板刚体 isStatic: true, render: &#123; visible: true &#125; &#125;); var backboardBlock = Matter.Bodies.rectangle(1069, 173, 5, 5, &#123; // 篮框边缘块 isStatic: true, render: &#123; visible: true &#125; &#125;); Matter.World.add(this.engine.world, [ // 四周墙壁 ... Matter.Bodies.rectangle(667, 5, 1334, 10, &#123; // x, y, w, h isStatic: true &#125;), ... ]); Matter.World.add(this.engine.world, [netBody, backboard, backboardBlock]);&#125; 六、判断进球、监听睡眠状态通过开启一个 tick 事件不停的监听球在运行时的位置，当到达某个位置时判定为进球。 另外太多的篮球会影响性能，所以我们使用 sleepStart 事件监听篮球一段时间不动后，进入睡眠状态时删除。 123456789101112...Matter.Events.on(this.engine, 'tick', function() &#123; countDown++; if (ball.position.x &gt; 1054 &amp;&amp; ball.position.x &lt; 1175 &amp;&amp; ball.position.y &gt; 170 &amp;&amp; ball.position.y &lt; 180 &amp;&amp; countDown &gt; 2) &#123; countDown = 0; console.log('球进了！'); &#125;&#125;);Matter.Events.on(ball, 'sleepStart', function() &#123; Matter.World.remove(This.engine.world, ball);&#125;);... 到此为止，通过借助物理引擎所提供的碰撞、弹性、摩擦力等特性，一款简易版的投篮小游戏就完成了，也推荐大家阅读另一位同事的文章【H5游戏开发】推金币 ，使用了 CreateJS + Matter.js 的方案，相信对你仿 3D 和 Matter.js 的使用上有更深的了解。 最后，此次项目中只做了一些小尝试，Matter.js 能实现的远不止这些，移步官网发现更多的惊喜吧，文章的完整 Demo 代码可【点击这里】。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考Matter.js LayaAir Demo","pubDate":"Thu, 16 Nov 2017 12:55:06 GMT","guid":"https://aotu.io/notes/2017/11/16/basketball/","category":"H5游戏开发"},{"title":"H5游戏开发：推金币","link":"https://aotu.io/notes/2017/11/06/coindozer/","description":"近期参与开发的一款「京东11.11推金币赢现金」（已下线）小游戏一经发布上线就在朋友圈引起大量传播。看到大家玩得不亦乐乎，同时也引发不少网友激烈讨论，有的说很带劲，有的大呼被套路被耍猴（无奈脸），这都与我的预期相去甚远。在相关业务数据呈呈上涨过程中，曾一度被微信「有关部门」盯上并要求做出调整，真是受宠若惊。接下来就跟大家分享下开发这款游戏的心路历程。 背景介绍一年一度的双十一狂欢购物节即将拉开序幕，H5 互动类小游戏作为京东微信手Q营销特色玩法，在今年预热期的第一波造势中，势必要玩点新花样，主要肩负着社交传播和发券的目的。推金币以传统街机推币机为原型，结合手机强大的能力和生态衍生出可玩性很高的玩法。 前期预研在体验过 AppStore 上好几款推金币游戏 App 后，发现游戏核心模型还是挺简单的，不过 H5 版本的实现在网上很少见。由于团队一直在做 2D 类互动小游戏，在 3D 方向暂时没有实际的项目输出，然后结合此次游戏的特点，一开始想挑战用 3D 来实现，并以此项目为突破口，跟设计师进行深度合作，抹平开发过程的各种障碍。 由于时间紧迫，需要在短时间内敲定方案可行性，否则项目延期人头不保。在快速尝试了 Three.js + Ammo.js 方案后，发现不尽人意，最终因为各方面原因放弃了 3D 方案，主要是不可控因素太多：时间上、设计及技术经验上、移动端 WebGL 性能表现上，主要还是业务上需要对游戏有绝对的控制，加上是第一次接手复杂的小游戏，担心项目无法正常上线，有点保守，此方案遂卒。 如果读者有兴趣的话可以尝试下 3D 实现，在建模方面，首推 Three.js ，入手非常简单，文档和案例也非常详实。当然入门的话必推这篇 Three.js入门指南，另外同事分享的这篇 Three.js 现学现卖 也可以看看，这里奉上粗糙的 推金币 3D 版 Demo 技术选型放弃了 3D 方案，在 2D 技术选型上就很从容了，最终确定用 CreateJS + Matter.js 组合作为渲染引擎和物理引擎，理由如下： CreateJS 在团队内用得比较多，有一定的沉淀，加上有老司机带路，一个字「稳」； Matter.js 身材纤细、文档友好，也有同事试玩过，完成需求绰绰有余。 技术实现因为是 2D 版本，所以不需要建各种模型和贴图，整个游戏场景通过 canvas 绘制，覆盖在背景图上，然后再做下机型适配问题，游戏主场景就处理得差不多了，其他跟 3D 思路差不多，核心元素包含障碍物、推板、金币、奖品和技能，接下来就分别介绍它们的实现思路。 障碍物通过审稿确定金币以及奖品的活动区域，然后把活动区域之外的区域都作为障碍物，用来限制金币的移动范围，防止金币碰撞时超出边界。这里可以用 Matter.js 的 Bodies.fromVertices 方法，通过传入边界各转角的顶点坐标一次性绘制出形状不规则的障碍物。 不过 Matter.js 在渲染不规则形状时存在问题，需要引入 poly-decomp 做兼容处理。 12345678910111213World.add(this.world, [ Bodies.fromVertices(282, 332,[ // 顶点坐标 &#123; x: 0, y: 0 &#125;, &#123; x: 0, y: 890 &#125;, &#123; x: 140, y: 815 &#125;, &#123; x: 208, y: 614 &#125;, &#123; x: 548, y: 614 &#125;, &#123; x: 612, y: 815 &#125;, &#123; x: 750, y: 890 &#125;, &#123; x: 750, y: 0 &#125; ])]); 推板 创建：\bCreateJS 根据推板图片创建 Bitmap 对象比较简单，就不详细讲解了。这里着重讲下推板刚体的创建，主要是跟推板 Bitmap 信息进行同步。因为推板视觉上表现为梯形，所以这里用的梯形刚体，实际上方形也可以，只要能跟周围障碍物形成封闭区域，防止出现缝隙卡住金币即可，创建的刚体直接挂载到推板对象上，方便后续随时提取（金币的处理也是一样），代码大致如下： 123456789var bounds = this.pusher.getBounds();this.pusher.body = Matter.Bodies.trapezoid( this.pusher.x, this.pusher.y, bounds.width, bounds.height&#125;);Matter.World.add(this.world, [this.pusher.body]); 伸缩：由于推板会沿着视线方向前后移动，为了达到近大远小效果，所以需要在推板伸长和收缩过程中进行缩放处理，这样也可以跟两侧的障碍物边沿进行贴合，让场景看起来更具真实感（伪 3D），当然金币和奖品也需要进行同样的处理。由于推板是自驱动做前后伸缩移动，所以需要对推板及其对应的刚体进行位置同步，这样才会与金币刚体产生碰撞达到推动金币的效果。同时在外部改变（伸长技能）推板最大长度时，也需要让推板保持均匀的缩放比而不至于突然放大／缩小，所以整个推板代码逻辑包含方向控制、长度控制、速度控制、缩放控制和同步控制，代码大致如下： 12345678910111213141516171819202122232425262728293031var direction, velocity, ratio, deltaY, minY = 550, maxY = 720, minScale = .74;Matter.Events.on(this.engine, 'beforeUpdate', function (event) &#123; // 长度控制（点击伸长技能时） if (this.isPusherLengthen) &#123; velocity = 90; this.pusherMaxY = maxY; &#125; else &#123; velocity = 85; this.pusherMaxY = 620; &#125; // 方向控制 if (this.pusher.y &gt;= this.pusherMaxY) &#123; direction = -1; // 移动到最大长度时结束伸长技能 this.isPusherLengthen = false; &#125; else if (this.pusher.y &lt;= this.pusherMinY) &#123; direction = 1; &#125; // 速度控制 this.pusher.y += direction * velocity; // 缩放控制，在最大长度变化时保持同样的缩放量，防止突然放大／缩小 ratio = (1 - minScale) * ((this.pusher.y - minY) / (maxY - minY)) this.pusher.scaleX = this.pusher.scaleY = minScale + ratio; // 同步控制，刚体跟推板位置同步 Body.setPosition(this.pusher.body, &#123; x: this.pusher.x, y: this.pusher.y &#125;);&#125;) 遮罩：推板伸缩实际上是通过改变坐标来达到位置上的变化，这样存在一个问题，就是在其伸缩时必然会导致缩进的部分「溢出」边界而不是被遮挡。 所以需要做遮挡处理，这里用 CreateJS 的 mask 遮罩属性可以很好的做「溢出」裁剪： 123var shape = new createjs.Shape();shape.graphics.beginFill('#ffffff').drawRect(0, 612, 750, 220);this.pusher.mask = shape 最终效果如下： 金币按正常思路，应该在点击屏幕时就在出币口创建金币刚体，让其在重力作用下自然掉落和回弹。但是在调试过程中发现，金币掉落后跟台面上其他金币产生碰撞会导致乱飞现象，甚至会卡到障碍物里面去（原因暂未知），后面改成用 TweenJS 的 Ease.bounceOut 来实现金币掉落动画，让金币掉落变得更可控，同时尽量接近自然掉落效果。这样金币从创建到消失过程就被拆分成了三个阶段： 第一阶段 点击屏幕从左右移动的出币口创建金币，然后掉落到台面。需要注意的是，由于创建金币时是通过 appendChild 方式加入到舞台的，这样金币会非常有规律的在 z 轴方向上叠加，看起来非常怪异，所以需要随机设置金币的 z-index，让金币叠加更自然，伪\b代码如下： 12var index = Utils.getRandomInt(1, Game.coinContainer.getNumChildren());Game.coinContainer.setChildIndex(this.coin, index); 第二阶段 由于金币已经不需要重力场，所以需要设置物理世界的\b重力为 0，这样金币不会因为自身重量（需要设置重量来控制碰撞时移动的速度）做自由落体运动，安安静静的平躺在台面上，等待跟推板、其他金币和障碍物之间产生碰撞： 12this.engine = Matter.Engine.create();this.engine.world.gravity.y = 0; 由于游戏主要逻辑都集中这个阶段，所以处理起来会稍微复杂些。真实情况下如果金币掉落并附着在推板上后，会跟随推板的伸缩而被带动，最终在推板缩进到最短时被背后的墙壁阻挡而挤下推板，此过程看起来简单但实现起来会非常耗时，最后因为时间上紧迫的这里也做了简化处理，就是不管推板是伸长还是缩进，都让推板上的金币向前「滑行」尽快脱离推板。一旦金币离开推板则立即为其创建同步的刚体，为后续的碰撞做准备，这样就完成了金币的碰撞处理。 12345678910111213141516171819202122232425262728293031Matter.Events.on(this.engine, 'beforeUpdate', function (event) &#123; // 处理金币与推板碰撞 for (var i = 0; i &lt; this.coins.length; i++) &#123; var coin = this.coins[i]; // 金币在推板上 if (coin.sprite.y &lt; this.pusher.y) &#123; // 无论推板伸长／缩进金币都往前移动 if (deltaY &gt; 0) &#123; coin.sprite.y += deltaY; &#125; else &#123; coin.sprite.y -= deltaY; &#125; // 金币缩放 if (coin.sprite.scaleX &lt; 1) &#123; coin.sprite.scaleX += 0.001; coin.sprite.scaleY += 0.001; &#125; &#125; else &#123; // 更新刚体坐标 if (coin.body) &#123; Matter.Body.set(coin.body, &#123; position: &#123; x: coin.sprite.x, y: coin.sprite.y &#125; &#125;) &#125; else &#123; // 金币离开推板则创建对应刚体 coin.body = Matter.Bodies.circle(coin.sprite.x, coin.sprite.y); Matter.World.add(this.world, [coin.body]); &#125; &#125; &#125;&#125;) 第三阶段 随着金币不断的投放、碰撞和移动，最终金币会从台面的下边沿掉落并消失，此阶段的处理同第一阶段，这里就不重复了。 奖品由于奖品需要根据业务情况进行控制，所以把它跟金币进行了分离不做碰撞处理（内心是拒绝的），所以产生了「螃蟹步」现象，这里就不做过多介绍了。 技能设计写好游戏主逻辑之后，技能就属于锦上添花的事情了，不过让游戏更具可玩性，想想金币哗啦啦往下掉的感觉还是很棒的。 抖动：这里取了个巧，是给舞台容器添加了 CSS3 实现的抖动效果，然后在抖动时间内让所有的金币的 y 坐标累加固定值产生整体慢慢前移效果，由于安卓下支持系统震动 API，所以加了个彩蛋让游戏体验更真实。 CSS3 抖动实现主要是参考了 csshake 这个样式，非常有意思的一组抖动动画集合。 JS 抖动 API 123456// 安卓震动if (isAndroid) &#123; window.navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate; window.navigator.vibrate([100, 30, 100, 30, 100, 200, 200, 30, 200, 30, 200, 200, 100, 30, 100, 30, 100]); window.navigator.vibrate(0); // 停止抖动&#125; 伸长：伸长处理也很简单，通过改变推板移动的最大 y 坐标值让金币产生更大的移动距离，不过细节上有几点需要注意的地方，在推板最大 y 坐标值改变之后需要保持移动速度不变，不然就会产生「瞬移」(不平滑)问题。 调试方法由于用了物理引擎，当在创建刚体时需要跟 CreateJS 图形保持一致，这里可以利用 Matter.js 自带的 Render 为物理场景独立创建一个透明的渲染层，然后覆盖在 CreateJS 场景之上，这里贴出大致代码： 12345678910Matter.Render.create(&#123; element: document.getElementById('debugger-canvas'), engine: this.engine, options: &#123; width: 750, height: 1206, showVelocity: true, wireframes: false // 设置为非线框，刚体才可以渲染出颜色 &#125;&#125;); 设置刚体的 render 属性为半透明色块，方便观察和调试，这里以推板为例： 123456789this.pusher.body = Matter.Bodies.trapezoid(... // 略&#123; isStatic: true, render: &#123; opacity: .5, fillStyle: 'red' &#125;&#125;); 效果如下，调试起来还是很方便的： 性能／体验优化控制对象数量随着游戏的持续台面上累积的金币数量会不断增加，金币之间的碰撞计算量也会陡增，必然会导致手机卡顿和发热。这时就需要控制金币的重叠度，而金币之间重叠的区域大小是由金币刚体的尺寸大小决定的，通过适当的调整刚体半径让金币分布得比较均匀，这样可以有效控制金币数量，提升游戏性能。 安卓卡顿一开始是给推板一个固定的速度进行伸缩处理，发现在 iOS 上表现流畅，但是在部分安卓机上却显得差强人意。由于部分安卓机型 FPS 比较低，导致推板在单位时间内位移比较小，表现出来就显得卡顿不流畅。后面让推板位移根据刷新时间差进行递增／减，保证不同帧频机型下都能保持一致的位移，代码大致如下： 1234567var delta = 0, prevTime = 0;Matter.Events.on(this.engine, 'beforeUpdate', function (event) &#123; delta = event.timestamp - prevTime; prevTime = event.timestamp; // ... 略 this.pusher.y += direction * velocity * (delta / 1000)&#125;) 对象回收这也是游戏开发中常用的优化手段，通过回收从边界消失的对象，让对象得以复用，防止因频繁创建对象而产生大量的内存消耗。 事件销毁由于金币和奖品生命周期内使用了 Tween，当他们从屏幕上消失后记得移除掉： 1createjs.Tween.removeTweens(this.coin); 至此，推金币各个关键环节都有讲到了，最后附上一张实际游戏效果： 结语感谢各位耐心读完，希望能有所收获，有考虑不足的地方欢迎留言指出。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 相关资源Three.js 官网 Three.js入门指南 Three.js 现学现卖 Matter.js 官网 Matter.js 2D 物理引擎试玩报告 .post-content img { display: block; margin: 20px auto; }","pubDate":"Mon, 06 Nov 2017 11:53:08 GMT","guid":"https://aotu.io/notes/2017/11/06/coindozer/","category":"H5游戏开发"},{"title":"H5动画：轨迹移动","link":"https://aotu.io/notes/2017/11/06/path-animation/","description":"动画，是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 在 Web 开发中，经常需要实现各种动画效果，例如：移动、变形、透明度变化等，今天我们主要来讨论各种移动的实现。 直线移动 通常可以直接由各个点的位置，以及到点的时间与整个动画持续时间的比值，写出类似下面的代码并可实现动画。 12345678910.cray &#123; animation: move 2s alternate infinite;&#125;@keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 30% &#123; transform: translate(100px, 0); &#125; 60% &#123; transform: translate(100px, 100px); &#125; 100% &#123; transform: translate(200px, 0); &#125;&#125; 曲线移动 在 CSS 中可以通过 transform-origin 配合 rotate 实现曲线移动，不过这种\b 曲线 都是圆的\b一部分且不太好控制。 这种移动我们可以把它拆分成两个方向的运动叠加，如 更详细的说明可以参考这篇文章 《curved-path-animations-in-css》。 路径移动 这也是曲线\b移动，但是想像上面那样，这个很难拆分成几个方向的运动叠加。这样的移动路径可以尝试以下几个方法： SVG Animation 这样的路径可以比较好的用 SVG path 来描述，然后使用 SVG Animation\b 做跟随动画，并可以达到预期的轨迹效果。 主要代码（在线示例）： 123456789101112131415161718&lt;svg width=\"420px\" height=\"260px\" viewBox=\"0 0 420 260\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;g stroke=\"#979797\" stroke-width=\"1\" fill=\"none\"&gt; &lt;path id=\"motionPath\" d=\"M370.378234,219.713623 C355.497359,218.517659 ...\" &gt;&lt;/path&gt; &lt;/g&gt; &lt;g id=\"cray\" transform=\"translate(0, -24)\" stroke=\"#979797\"&gt; &lt;image id=\"cray-img\" xlink:href=\"http://7xt5iu.com1.z0.glb.clouddn.com/img/cray.png\" x=\"0\" y=\"0\" width=\"100px\"/&gt; &lt;/g&gt; &lt;animateMotion xlink:href=\"#cray\" dur=\"5s\" begin=\"0s\" fill=\"freeze\" repeatCount=\"indefinite\" rotate=\"auto-reverse\" &gt; &lt;mpath xlink:href=\"#motionPath\" /&gt; &lt;/animateMotion&gt;&lt;/svg&gt; 效果： JavaScript 使用 JavaScript 可以直接操作元素进行运动，理论上可以实现任何动画，只是实现一些复杂的动画成本比较高，好在有各种已经开发好了的工具库可以供我们使用。例如，使用 Greensock 的 TweenMax 和 MorphSVGPlugin（收费），通过 MorphSVGPlugin 提供的 pathDataToBezier 方法将 \bSVG path 转成曲线数组，然后给 TweenMax 使用： 123456789101112var hill = document.getElementById('hill')var path = MorphSVGPlugin.pathDataToBezier(\"#motionPath\");TweenMax.to(hill, 5, &#123; bezier:&#123; values:path, type:\"cubic\", autoRotate: 180 &#125;, ease:Linear.easeNone, repeat: -1&#125;) 在线示例 CSS 实现动画，其实就是在相应的时间点做相应的“变化”。再回头看直线移动的实现方式，其实如果能给出足够多点的位置和该点的时间与持续时间的比值，那其实曲线也可以直接用 CSS 来实现。 很多时候设计师使用 AE 来设计动画，当我们拿到设计稿后，可以给动画增加关键帧，然后借助一些工具把关键帧的信息导出来，这里介绍一个 keyframes-cli，可以导出这样结构的数据 从属性名字可以判断出来 X_POSITION 和 Y_POSITION 是 x 和 y 的位置信息，而 key_values 里的 data 就是我们需要的点位置， 该点的时间与持续时间的比值 可以根据 start_frame 得出，写个脚本把这些数据处理下，可得到类似下面的 CSS 代码 设置的关键帧越多，动画会越流畅，但 CSS 也会增多。 注意：不是 AE 关键帧里所有的信息都可以导出来，还跟 AE 里使用的过渡属性有关，这里有介绍。 最后，总结一下，移动动画就是用一种合适的方式把时间和位置的变化关系展示出来。除了上面方法，肯定还有很多其他的方法和帮助工具，欢迎留言交流讨论。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。","pubDate":"Mon, 06 Nov 2017 10:27:36 GMT","guid":"https://aotu.io/notes/2017/11/06/path-animation/","category":"Web开发"},{"title":"H5游戏开发：一笔画","link":"https://aotu.io/notes/2017/11/02/onestroke/","description":"一笔画是图论科普中一个著名的问题，它起源于柯尼斯堡七桥问题科普。数学家欧拉在他1736年发表的论文《柯尼斯堡的七桥》中不仅解决了七桥问题，也提出了一笔画定理，顺带解决了一笔画问题。用图论的术语来说，对于一个给定的连通图科普存在一条恰好包含所有线段并且没有重复的路径，这条路径就是「一笔画」。 寻找连通图这条路径的过程就是「一笔画」的游戏过程，如下： 游戏的实现「一笔画」的实现不复杂，笔者把实现过程分成两步： 底图绘制 交互绘制 「底图绘制」把连通图以「点线」的形式显示在画布上，是游戏最容易实现的部分；「交互绘制」是用户绘制解题路径的过程，这个过程会主要是处理点与点动态成线的逻辑。 底图绘制「一笔画」是多关卡的游戏模式，笔者决定把关卡（连通图）的定制以一个配置接口的形式对外暴露。对外暴露关卡接口需要有一套描述连通图形状的规范，而在笔者面前有两个选项： 点记法 线记法 举个连通图 —— 五角星为例来说一下这两个选项。 点记法如下：123456789101112131415levels: [ // 当前关卡 &#123; name: \"五角星\", coords: [ &#123;x: Ax, y: Ay&#125;, &#123;x: Bx, y: By&#125;, &#123;x: Cx, y: Cy&#125;, &#123;x: Dx, y: Dy&#125;, &#123;x: Ex, y: Ey&#125;, &#123;x: Ax, y: Ay&#125; ] &#125; ...] 线记法如下：12345678910111213levels: [ // 当前关卡 &#123; name: \"五角星\", lines: [ &#123;x1: Ax, y1: Ay, x2: Bx, y2: By&#125;, &#123;x1: Bx, y1: By, x2: Cx, y2: Cy&#125;, &#123;x1: Cx, y1: Cy, x2: Dx, y2: Dy&#125;, &#123;x1: Dx, y1: Dy, x2: Ex, y2: Ey&#125;, &#123;x1: Ex, y1: Ey, x2: Ax, y2: Ay&#125; ] &#125;] 「点记法」记录关卡通关的一个答案，即端点要按一定的顺序存放到数组 coords中，它是有序性的记录。「线记法」通过两点描述连通图的线段，它是无序的记录。「点记法」最大的优势是表现更简洁，但它必须记录一个通关答案，笔者只是关卡的搬运工不是关卡创造者，所以笔者最终选择了「线记法」。：） 交互绘制在画布上绘制路径，从视觉上说是「选择或连接连通图端点」的过程，这个过程需要解决2个问题： 手指下是否有端点 选中点到待选中点之间能否成线 收集连通图端点的坐标，再监听手指滑过的坐标可以知道「手指下是否有点」。以下伪代码是收集端点坐标： 12345678// 端点坐标信息let coords = [];lines.forEach((&#123;x1, y1, x2, y2&#125;) =&gt; &#123; // (x1, y1) 在 coords 数组不存在 if(!isExist(x1, y1)) coords.push([x1, y1]); // (x2, y2) 在 coords 数组不存在 if(!isExist(x2, y2)) coords.push([x2, y2]);&#125;); 以下伪代码是监听手指滑动：1234567891011121314easel.addEventListener(\"touchmove\", e =&gt; &#123; let x0 = e.targetTouches[0].pageX, y0 = e.targetTouches[0].pageY; // 端点半径 ------ 取连通图端点半径的2倍，提升移动端体验 let r = radius * 2; for(let [x, y] of coords)&#123; if(Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0), 2) &lt;= r)&#123; // 手指下有端点，判断能否连线 if(canConnect(x, y)) &#123; // todo &#125; break; &#125; &#125;&#125;) 在未绘制任何线段或端点之前，手指滑过的任意端点都会被视作「一笔画」的起始点；在绘制了线段（或有选中点）后，手指滑过的端点能否与选中点串连成线段需要依据现有条件进行判断。 上图，点A与点B可连接成线段，而点A与点C不能连接。笔者把「可以与指定端点连接成线段的端点称作有效连接点」。连通图端点的有效连接点从连通图的线段中提取：1234567891011121314coords.forEach(coord =&gt; &#123; // 有效连接点（坐标）挂载在端点坐标下 coord.validCoords = []; lines.forEach((&#123;x1, y1, x2, y2&#125;) =&gt; &#123; // 坐标是当前线段的起点 if(coord.x === x1 &amp;&amp; coord.y === y1) &#123; coord.validCoords.push([x2, y2]); &#125; // 坐标是当前线段的终点 else if(coord.x === x2 &amp;&amp; coord.y === y2) &#123; coord.validCoords.push([x1, y1]); &#125; &#125;)&#125;) But…有效连接点只能判断两个点是否为底图的线段，这只是一个静态的参考，在实际的「交互绘制」中，会遇到以下情况： 如上图，AB已串连成线段，当前选中点B的有效连接点是 A 与 C。AB 已经连接成线，如果 BA 也串连成线段，那么线段就重复了，所以此时 BA 不能成线，只有 AC 才能成线。 对选中点而言，它的有效连接点有两种： 与选中点「成线的有效连接点」 与选中点「未成线的有效连接点」 其中「未成线的有效连接点」才能参与「交互绘制」，并且它是动态的。 回头本节内容开头提的两个问题「手指下是否有端点」 与 「选中点到待选中点之间能否成线」，其实可合并为一个问题：手指下是否存在「未成线的有效连接点」。只须把监听手指滑动遍历的数组由连通图所有的端点坐标 coords 替换为当前选中点的「未成线的有效连接点」即可。 至此「一笔画」的主要功能已经实现。可以抢先体验一下： https://leeenx.github.io/OneStroke/src/onestroke.html 自动识图笔者在录入关卡配置时，发现一个7条边以上的连通图很容易录错或录重线段。笔者在思考能否开发一个自动识别图形的插件，毕竟「一笔画」的图形是有规则的几何图形。 上面的关卡「底图」，一眼就可以识出三个颜色： 白底 端点颜色 线段颜色 并且这三种颜色在「底图」的面积大小顺序是：白底 &gt; 线段颜色 &gt; 端点颜色。底图的「采集色值表算法」很简单，如下伪代码： 12345678910let imageData = ctx.getImageData();let data = imageData.data;// 色值表let clrs = new Map();for(let i = 0, len = data.length; i &lt; len; i += 4) &#123; let [r, g, b, a] = [data[i], data[i + 1], data[i + 2], data[i + 3]]; let key = `rgba($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;, $&#123;a&#125;)`; let value = clrs.get(key) || &#123;r, g, b, a, count: 0&#125;; clrs.has(key) ? ++value.count : clrs.set(rgba, &#123;r, g, b, a, count&#125;);&#125; 对于连通图来说，只要把端点识别出来，连通图的轮廓也就出来了。 端点识别理论上，通过采集的「色值表」可以直接把端点的坐标识别出来。笔者设计的「端点识别算法」分以下2步： 按像素扫描底图直到遇到「端点颜色」的像素，进入第二步 从底图上清除端点并记录它的坐标，返回继续第一步 伪代码如下：12345678910for(let i = 0, len = data.length; i &lt; len; i += 4) &#123; let [r, g, b, a] = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // 当前像素颜色属于端点 if(isBelongVertex(r, g, b, a)) &#123; // 在 data 中清空端点 vertex = clearVertex(i); // 记录端点信息 vertexes.push(vertext); &#125;&#125; But… 上面的算法只能跑无损图。笔者在使用了一张手机截屏做测试的时候发现，收集到的「色值表」长度为 5000+ ！这直接导致端点和线段的色值无法直接获得。 经过分析，可以发现「色值表」里绝大多数色值都是相近的，也就是在原来的「采集色值表算法」的基础上添加一个近似颜色过滤即可以找出端点和线段的主色。伪代码实现如下： 123456789let lineColor = vertexColor = &#123;count: 0&#125;;for(let clr of clrs) &#123; // 与底色相近，跳过 if(isBelongBackground(clr)) continue; // 线段是数量第二多的颜色，端点是第三多的颜色 if(clr.count &gt; lineColor.count) &#123; [vertexColor, lineColor] = [lineColor, clr] &#125;&#125; 取到端点的主色后，再跑一次「端点识别算法」后居识别出 203 个端点！这是为什么呢？ 上图是放大5倍后的底图局部，蓝色端点的周围和内部充斥着大量噪点（杂色块）。事实上在「端点识别」过程中，由于噪点的存在，把原本的端点被分解成十几个或数十个小端点了，以下是跑过「端点识别算法」后的底图： 通过上图，可以直观地得出一个结论：识别出来的小端点只在目标（大）端点上集中分布，并且大端点范围内的小端点叠加交错。 如果把叠加交错的小端点归并成一个大端点，那么这个大端点将十分接近目标端点。小端点的归并伪代码如下： 1234567891011121314for(let i = 0, len = vertexes.length; i &lt; len - 1; ++i) &#123; let vertexA = vertexes[i]; if(vertextA === undefined) continue; // 注意这里 j = 0 而不是 j = i +1 for(let j = 0; j &lt; len; ++j) &#123; let vertexB = vertexes[j]; if(vertextB === undefined) continue; // 点A与点B有叠加，点B合并到点A并删除点B if(isCross(vertexA, vertexB)) &#123; vertexA = merge(vertexA, vertexB); delete vertexA; &#125; &#125;&#125; 加了小端点归并算法后，「端点识别」的准确度就上去了。经笔者本地测试已经可以 100% 识别有损的连通图了。 线段识别笔者分两个步骤完成「线段识别」： 给定的两个端点连接成线，并采集连线上N个「样本点」； 遍历样本点像素，如果像素色值不等于线段色值则表示这两个端点之间不存在线段 如何采集「样式点」是个问题，太密集会影响性能；太疏松精准度不能保证。 在笔者面前有两个选择：N 是常量；N 是变量。假设 N === 5。局部提取「样式点」如下： 上图，会识别出三条线段：AB, BC 和 AC。而事实上，AC不能成线，它只是因为 AB 和 BC 视觉上共一线的结果。当然把 N 值向上提高可以解决这个问题，不过 N 作为常量的话，这个常量的取量需要靠经验来判断，果然放弃。 为了避免 AB 与 BC 同处一直线时 AC 被识别成线段，其实很简单 —— 两个「样本点」的间隔小于或等于端点直径。假设 N = S / (2 * R)，S 表示两点的距离，R 表示端点半径。局部提取「样式点」如下： 如上图，成功地绕过了 AC。「线段识别算法」的伪代码实现如下：123456789101112131415for(let i = 0, len = vertexes.length; i &lt; len - 1; ++i) &#123; let &#123;x: x1, y: y1&#125; = vertexes[i]; for(let j = i + 1; j &lt; len; ++j) &#123; let &#123;x: x2, y: y2&#125; = vertexes[j]; let S = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); let N = S / (R * 2); let stepX = (x1 - x2) / N, stepY = (y1 - y2) / n; while(--N) &#123; // 样本点不是线段色 if(!isBelongLine(x1 + N * stepX, y1 + N * stepY)) break; &#125; // 样本点都合格 ---- 表示两点成线，保存 if(0 === N) lines.push(&#123;x1, y1, x2, y2&#125;) &#125;&#125; 性能优化由于「自动识图」需要对图像的的像素点进行扫描，那么性能确实是个需要关注的问题。笔者设计的「自动识图算法」，在识别图像的过程中需要对图像的像素做两次扫描：「采集色值表」 与 「采集端点」。在扫描次数上其实很难降低了，但是对于一张 750 * 1334 的底图来说，「自动识图算法」需要遍历两次长度为 750 * 1334 * 4 = 4,002,000 的数组，压力还是会有的。笔者是从压缩被扫描数组的尺寸来提升性能的。 被扫描数组的尺寸怎么压缩？笔者直接通过缩小画布的尺寸来达到缩小被扫描数组尺寸的。伪代码如下： 12345// 要压缩的倍数let resolution = 4;let [width, height] = [img.width / resolution &gt;&gt; 0, img.height / resolution &gt;&gt; 0];ctx.drawImage(img, 0, 0, width, height);let imageData = ctx.getImageData(), data = imageData; 把源图片缩小4倍后，得到的图片像素数组只有原来的 4^2 = 16倍。这在性能上是很大的提升。 使用「自动识图」的建议尽管笔者在本地测试的时候可以把所有的「底图」识别出来，但是并不能保证其它开发者上传的图片能否被很好的识别出来。笔者建议，可以把「自动识图」做为一个单独的工具使用。 笔者写了一个「自动识图」的单独工具页面：https://leeenx.github.io/OneStroke/src/plugin.html可以在这个页面生成对应的关卡配置。 结语下面是本文介绍的「一笔画」的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/OneStroke其中游戏实现的主体代码在：https://github.com/leeenx/OneStroke/blob/master/src/script/onestroke.es6自动识图的代码在：https://github.com/leeenx/OneStroke/blob/master/src/script/oneStrokePlugin.es6 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 .post-content sup a { vertical-align: unset; }","pubDate":"Thu, 02 Nov 2017 11:30:37 GMT","guid":"https://aotu.io/notes/2017/11/02/onestroke/","category":"H5游戏开发"},{"title":"H5游戏开发：横屏适配","link":"https://aotu.io/notes/2017/10/18/landscape_mode_in_html5_game/","description":"对于移动端的轻量级 HTML5 互动小游戏（简称为 H5 轻互动)，如果从屏幕呈现模式来划分的话，可以归类为：竖屏式和横屏式。 HTML5互动小游戏案例截图 平常我们做过的需求里，主要是以竖屏式为主，而横屏式较少。对于竖屏式场景来说，大家的经验会比较丰富，因此，此次主要式探讨下横屏式场景下的一些需要注意的点，特别是怎样去做横屏适配。 对于 H5 轻互动游戏来说，要实现横屏的话，主要是解决两点：1.无论用户手持方向如何，都需要保证屏幕横向显示。2.由于屏幕分辨率的多样化，因此就算是横屏下也是需要进行横屏适配，保证画面在所有分辨率下都能够合理适配。 下面，我们针对这两点分别阐述如何解决。 强制横屏显示页面内容显示方向可分为竖排方向和横排方向，如下图所示。 页面内容显示方式：竖向排版和横向排版 对于竖屏式 H5 轻互动来说，页面会被期望保持竖排方向显示。而如果页面出现横排方向显示的情况，开发者往往会选择利用提示蒙层来进行友好提示，让用户自主保持竖屏体验，如下图所示。 提示蒙层提醒用户保持竖屏体验 同样地，在横屏式 H5 轻互动游戏中可以采取相同的措施进行简单处理，在页面内容按竖排方向显示时，开发者进行对用户提示其保持横屏体验。 但是，这对用户体验并不友好，因为这对于那些习惯于打开锁定为竖排方向功能（如下图所示）的 iOS 平台用户，或者是关闭屏幕旋转功能（如下图所示）的 Android 平台用户来说，他们需要多一个处理步骤——先关闭竖排方向锁定或是开启屏幕旋转，然后再横向手持设备。 竖排方向锁定功能（iOS）与屏幕旋转（Android）功能 因此，更好的做法是强制横屏显示，对屏幕 resize 事件进行监听，当判断为竖屏时将整个根容器进行逆时针 CSS3 旋转 90 度即可，代码如下所示。 1234567891011121314151617181920212223242526// 利用 CSS3 旋转 对根容器逆时针旋转 90 度var detectOrient = function() &#123; var width = document.documentElement.clientWidth, height = document.documentElement.clientHeight, $wrapper = document.getElementById(\"J_wrapper\"), style = \"\"; if( width &gt;= height )&#123; // 横屏 style += \"width:\" + width + \"px;\"; // 注意旋转后的宽高切换 style += \"height:\" + height + \"px;\"; style += \"-webkit-transform: rotate(0); transform: rotate(0);\"; style += \"-webkit-transform-origin: 0 0;\"; style += \"transform-origin: 0 0;\"; &#125; else&#123; // 竖屏 style += \"width:\" + height + \"px;\"; style += \"height:\" + width + \"px;\"; style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\"; // 注意旋转中点的处理 style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\"; style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\"; &#125; $wrapper.style.cssText = style;&#125;window.onresize = detectOrient;detectOrient(); 但是！这里有坑：如果你是采用 CreateJS 框架进行开发，那么就不能通过 CSS3 途径对包含 Canvas 的根容器进行旋转处理，因为旋转后会导致 Canvas 内的舞台元素的事件响应位置错乱。解决办法是，换成利用 CreateJS 框架内的 Stage 的 rotation 属性对整个舞台旋转处理，代码如下： 12345678910if(self.isPortrait) &#123; // 竖屏 // 舞台旋转 self.stage.x = self.canvasHeight; // 注意：x偏移相当于旋转中点处理，更简单 self.stage.rotation = 90; // more...&#125;else &#123; // 横屏 self.stage.x = 0; self.stage.rotation = 0; // more...&#125; 横屏适配处理面对移动端多分辨率繁复冗杂的情况，我们对于一般情况下（也就是常见的竖屏式）页面适配处理可以说是烂熟于心，但是切换到横屏式场景下，同样的页面适配方法可以直接应用吗？会不会有什么问题呢？ 下面笔者分别从 DOM 和 Canvas 两方面去着手阐述如何做横屏适配处理。 解决 DOM 的横屏适配问题在移动端，常见的移动端适配方案是 REM 方案，而为了减少 JS 与 CSS 的耦合，笔者团队开发页面时采用的是 VW + REM 方案。（想要了解该方案的同学可详细阅读《利用视口单位实现适配布局》）。 因为页面适配的场景往往是竖屏式的，因此 VW + REM 方案表现得十分完美。但是遇上横屏式，它的缺点就暴露了出来。 现行的 vw 单位适配方案带来的问题 如上图所示，由于响应断点的限制最大宽度处理，会导致页面两侧留白，当然这可以通过去掉最大宽度限制来解决。而真正的缺点在于，由于 vw 单位的特性，适配换算大小是根据屏幕宽度而言的，因此屏幕宽度越大导致容器、文字会越大，还可能导致 DOM 元素超出屏幕外，且文字过大并不是我们所想要的用户体验。 那么，换成 px 单位的固定布局如何？ 但 px 单位的固定布局只适合于部分场景，对于需要内容全屏覆盖的场景（如下图所示），就可能存在这样的不理想的用户体验：绝对定位的元素之间空隙过大，导致布局不美观，又或者空隙过小，导致元素叠放被遮挡。 px单位固定布局适配方案带来的问题 我们了解到，vw 单位的特点是适配换算大小时是根据屏幕宽度而定的，那么在强制横屏显示时，我们就可以同理转换为屏幕高度来而定，也就是 vw 单位替换成 vh 单位。 这样进一步改良之后就会得到满意的适配效果，如下图所示。 更好的适配解决方案—— vw、vh 单位搭配 具体实现可参考如下 SCSS 代码：123456789101112$vw_base: 375;$vw_fontsize: 20;html &#123; font-size: 20px; //不支持vw单位时，回退到px单位 font-size: ($vw_fontsize / $vw_base) * 100vw;&#125;@media screen and (orientation: landscape) &#123; html &#123; font-size: 20px; font-size: ($vw_fontsize / $vw_base) * 100vh; &#125;&#125; 解决 Canvas 的横屏适配问题解决 Canvas 的横屏适配问题，目前在实际应用中有两种主流的方案： 通过做两套Canvas的方案。 采用缩放的手段进行适配的方案。 两套 Canvas 的方案的做法是，页面包含两个 Canvas 分别用于横竖屏时的相应显示，但是它们的数据是打通的。但是，该方案难免会有局限性，比较适合游戏逻辑数据处理简单、且舞台元素少且居中的场景； 而缩放适配方案做法是，采用的最为常见的缩放手段——利用 CSS3 Transform 的 scale 属性，达到“一种设计尺寸适配多种分辨率屏幕”的目的。 采用了不同适配方案的案例 在市面上的一些成熟的主流 HTML5 游戏引擎，例如 Cocos2D、Laya、Egret 等等，它们本身就集成了横屏适配的方案。如果你有去了解过，可以发现它们普遍都是采用缩放的理念进行适配。 但是，对于我们常用的 CreateJS、PixiJS 框架来说，它们并没有配套的现成的横屏适配解决方案可以被采用的，尤其是我们如果采用原生 Javascript 去开发一个横屏游戏的时候。 因此，下面我们来研究下如何解决 Canvas 横屏适配问题。 注意：下面文中示例代码都是在 CreateJS 框架的基础上进行编写的。 选用合适的缩放模式横屏适配的核心是缩放，通过 scale 属性等手法将Canvas缩放至适合屏幕窗口大小。类似于 background-size 属性的表现，缩放适配也可以有很多种模式，或有裁剪或无裁剪，或根据长边缩放或根据短边缩放等等。根据一些常见的实际应用场景，有比较常用的五种缩放模式：Contain、Cover、Fill、Fixed-Width、Fixed-Height。根据游戏的不同的实际场景需求，我们可以选其中一种缩放模式进行适配。 下面，我们逐一解释以上五种缩放模式的定义、实现与其适用的场景。 a. Contain模式 Canvas可以类比为一张图，而图片的适配，我们可以联想到经常用以适配背景图片的属性 background-size ，其属性值包括 contain、cover。 借助 contain 的概念，我们把缩放的其中一种模式称为 Contain 模式。因为在这种模式下，舞台内容（gameArea）会保持宽高比进行缩放适配浏览器可视窗口（window），缩放至其能显示完整的舞台内容。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的宽度比或高度比之间较小者。 Contain 模式下的缩放比例推导图 根据推导结论，简单代码实现如下： 1234567// Contain模式核心原理函数CONTAIN: function()&#123; var self = this; self.radioX = self.radioY = Math.min((self.winWidth / self.designWidth) , (self.winHeight / self.designHeight)); self.canvasWidth = self.designWidth; self.canvasHeight = self.designHeight;&#125; 可以看出，在 Contain 模式下，如果舞台内容宽高比与浏览器可视窗口的宽高比不相等时，舞台内容并没有填满整个浏览器可视窗口，此时就会出现上下或左右两侧会存在留空部分。 对于这种 Contain 模式，会比较适合舞台背景为纯色或者是渐变类型的H5轻互动，舞台内容与窗口的紧邻处得以自然过渡衔接，不会突兀。 b. Cover模式 同样地，借助 cover 的概念把其中一种模式称为 Cover 模式。在这种模式下，舞台内容（gameArea）会保持宽高比进行缩放适配浏览器可视窗口（window），缩放至舞台内容填满窗口。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的宽度比或高度比之间较大者。 Cover 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：1234567// Cover模式核心原理函数COVER: function()&#123; var self = this; self.radioX = self.radioY = Math.max((self.winWidth / self.designWidth) , (self.winHeight / self.designHeight)); self.canvasWidth = self.designWidth; self.canvasHeight = self.designHeight;&#125; 在 Cover 模式下，如果舞台内容宽高比与浏览器可视窗口的宽高比不相等时，由于舞台内容需要填满整个浏览器可视窗口，此时就会出现上下或者左右两侧被裁剪的情况。 那么，如果能保证游戏场景内的重点显示内容全部显示，被裁剪内容无关紧要时，那么这种 H5 轻互动类型就可以考虑采用 Cover 模式。 怎么做到保证想要重点显示的内容可以不被裁剪呢？这时要谈到一个“安全区域”的概念，指的是绝对不会被裁剪的内容区域，它应该是由最小的屏幕可视窗口（目前应该是 iPhone 4 ）与最大的屏幕可视窗口（目前应该是 iPhone 7 Plus）叠加后得出的重叠区域，如下图所示。 “安全区域”即为红色虚线框内部分 开发者应该在设计阶段与设计师、产品等相关人员进行沟通，告知其不想被裁剪的内容都应该在“安全区域”进行设计布局。 c. Fill模式 Fill 模式，可以类比为 backgrouns-size: 100% 100% 的表现，在这种模式下，不会保持宽高比，舞台内容（gameArea）的宽高分别按照舞台内容与浏览器可视窗口（window）的宽度比与高度比进行缩放，缩放至舞台内容拉伸铺满窗口。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为对于游戏内容的宽应用其与可视窗口的宽度比，而游戏内容的高应用其与可视窗口的高度比。 Fill 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：12345678// Fill模式核心原理函数FILL: function()&#123; var self = this; self.radioX = (self.winWidth / self.stageWidth); self.radioY = (self.winHeight / self.stageHeight); self.canvasWidth = self.designWidth; self.canvasHeight = self.designHeight;&#125; 这种模式下既不会留空，也不会被裁剪，但是在舞台内容宽高比与浏览器可视窗口的宽高比不相等时，显示的内容会有一定程度的拉伸形变。 这种暴力的处理方式虽然免去了留空和裁剪的烦恼，但是会存在拉伸形变，这就得看是否能够被接受了。 d. Fixed-Width模式 区别于图像，Canvas 是可以进行动态绘制大小的。所以，我们可以考虑根据屏幕窗口大小变化来动态绘制 Canvas。从保持舞台横向内容不变的角度考虑，我们提出这样的模式：舞台内容（gameArea）等比进行缩放至与浏览器可视窗口的一致的宽度大小，而舞台的高度（Canvas高度）进行重新绘制其高度为浏览器可视窗口的高度，称之为 Fixed-Width 模式。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的宽度比。 Fixed-Width 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：1234567// Fixed-Width模式核心原理函数FIXED_WIDTH: function()&#123; var self = this; self.radioX = self.radioY = self.winWidth / self.designWidth; self.canvasWidth = self.designWidth; self.canvasHeight = self.winHeight / self.radioY;&#125; 在 Fixed-Width 模式下，无论在什么分辨率下，舞台横向内容保持不变，而纵向高度则会动态裁补，这就会比较适用于那些场戏场景可以纵向拓展的 H5 轻互动类型。 e. Fixed-Height模式 说完 Fixed-Width 模式，换个角度考虑便得出 Fixed-Height 模式，舞台内容（gameArea）等比进行缩放至与浏览器可视窗口的一致的高度大小，而舞台的宽度（Canvas宽度）进行重新绘制其宽度为浏览器可视窗口的宽度。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的高度比。 Fixed-Height 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：1234567// Fixed-Height模式核心原理函数FIXED_HEIGHT: function()&#123; var self = this; self.radioX = self.radioY= self.winHeight / self.designHeight; self.canvasWidth = self.winWidth / self.radioX; self.canvasHeight = self.designHeight;&#125; 与 Fixed-Width 模式相反，Fixed-Height 模式下，舞台纵向内容保持不变，而横向宽度则会动态裁补。对于这种模式的应用场景应该会比较广泛，譬如常见的跑酷游戏类型H5轻互动。 加入重定位和重绘制策略综合以上五种缩放模式，我们可以看到对于 Cover、Fixed-Width、Fixed-Height 模式而言，有存在被裁剪的可能性。特别是 Fixed-Height 模式，对于横屏游戏来说这是比较常用的模式，但是在屏幕较小的时候难免会被裁剪，而且我们是不希望贴边元素被裁剪掉的，譬如位于右上角的音乐图标。而对于 Fixed-Width、Fixed—Height 模式，它们还存在舞台区域需要补充绘制的情况，因此对某些舞台元素来说需要重新设定其渲染大小。 所以，除了基本的缩放适配模式实现之外，为了解决贴边元素不被裁剪以及对一些舞台元素重绘制的需求，我们还需要加入两个策略：重定位和重绘制。 a. 重定位 贴边元素重定位策略的实现原理很简单，对需要重新定位的元素对象额外设置 top、left、right、bottom 的自定义属性（当然你可以命名为其他属性名），这样我们就可以在适配的时候根据这些自定义属性以及实际显示的 Canvas 大小进行重新计算位置。 为了保证性能，下面是策略里需要注意的地方： 在舞台里，并不是所有游戏元素都是需要被重定位的，因此我们只需要创建一个数组记录需要被重定位的元素。 适当控制重定位次数，我们不需要在每一帧 tick 绘制的时候都进行重定位，只需要在 Canvas 大小改变的时候进行处理。 以下是重定位策略相关的代码：123456789101112131415161718192021222324252627282930// halfCutHeight、halfCutWidth是根据适配后的实际Canvas大小计算出来的相对距离_setSize: function()&#123; // ... if(self.isPortrait) &#123; // ... self.halfCutWidth = (self.canvasWidth * self.radioY - this.winWidth ) / 2 / self.radioY; self.halfCutHeight = (self.canvasHeight * self.radioX - this.winHeight) / 2 / self.radioX; &#125;else &#123; // ... self.halfCutWidth = (self.canvasWidth * self.radioX - this.winWidth ) / 2 / self.radioX; self.halfCutHeight = (self.canvasHeight * self.radioY - this.winHeight) / 2 / self.radioY; &#125; // ...&#125;,// 贴边元素重定位核心处理函数_adjustPosition: function(item)&#123; var self = this; item &amp;&amp; self.adjustPositionArr.push(item); self.adjustPositionArr.map(function(item, index, arr)&#123; (typeof item.top == \"number\") &amp;&amp; (item.y = item.top + self.halfCutHeight &gt;= 0 ? self.halfCutHeight : 0); (typeof item.left == \"number\") &amp;&amp; (item.x = item.left + self.halfCutWidth &gt;= 0 ? self.halfCutWidth : 0); (typeof item.bottom == \"number\") &amp;&amp; (item.y = self.canvasHeight - item.getBounds().height - item.bottom + self.halfCutHeight &gt;= 0 ? self.halfCutHeight : 0); (typeof item.right == \"number\") &amp;&amp; (item.x = self.canvasWidth - item.getBounds().width - item.right - self.halfCutWidth); &#125;);&#125;,// 暴露方法：提供给开发者记录需要重定位的贴边元素adjustPosition: function(item)&#123; var self = this; self._adjustPosition(item);&#125; b. 重绘制 对于一些以舞台区域（gameArea）作为其大小设置的参考标准的元素，在适配时遇到需要补全绘制区域时，舞台区域大小发生变化，相应地，该元素就需要进行重新绘制，这就是重绘制策略的存在意义。 同样地，为了保证性能，重绘制策略也是同样需要保证： 创建对应的数组记录全显图形对象。 不在每一帧 tick 时进行重绘制，只在适配的时候重绘制。 以下是重绘制策略的相关代码：12345678910111213// 全显图形重绘制核心处理函数_adjustFullSize: function(item)&#123; var self = this; item &amp;&amp; self.adjustFullSizeArr.push(item); self.adjustFullSizeArr.map(function(item, index, arr)&#123; item.drawRect(0, 0, self.canvasWidth, self.canvasHeight); &#125;);&#125;,// 暴露方法：提供给开发者记录需要重绘制的全显图形adjustPosition: function(item)&#123; var self = this; self._adjustPosition(item);&#125; 至此，Canvas 横屏适配问题才得以完全解决。 这部分内容篇幅较长，笔者简单总结下，一个简单的解决 Canvas 横屏适配问题的方案至少需要包括两点实现： 选用合适的缩放模式。方案内置五种缩放模式，在实际应用中根据场景不同而采用不同的缩放进行适配。 加入重定位和重绘制策略。为了保证贴边元素不被裁剪以及舞台元素动态渲染大小以适应舞台区域的动态变化。 最终的整体效果可前往体验地址进行体验，体验时可点击文本元素进行切换模式。另外，整体的实现方案是基于 CreateJS 框架进行实现的，文中的实现方案的代码会托管笔者github上。 后话本文主要的核心在于探讨横屏游戏中的处理点与解决方案，因此如果实现代码方面有任何错漏之处，请大胆地提出纠正吧！又或者读者们有更好的见解之处，也欢迎留言分享噢。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料《如何打造一个高效适配的H5》《Cocos2d-JS的屏幕适配方案》《Cocos2d-JS 多分辨率适配方案》《Cocos2d-JS 对齐策略》《Laya引擎－自动横屏适配》《Phaser－scaleManager对象》《How to create mobile games for different screen sizes and resolutions》《Egret－屏幕适配策略》","pubDate":"Wed, 18 Oct 2017 01:10:00 GMT","guid":"https://aotu.io/notes/2017/10/18/landscape_mode_in_html5_game/","category":"H5游戏开发"},{"title":"js创建一条通用链表","link":"https://aotu.io/notes/2017/10/13/make-a-chain-class/","description":"什么是「链表科普」？ 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 什么是「顺序存储结构科普」？ 在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素,称作线性表的顺序存储结构。 多数高级语言的「数组」使用「顺序存储结构」，不过早期的 javascript 引擎用了「链式存储结构」。Chrome 的 V8 的数组使用了「顺序存储结构」与「链式存储结构」混合模式；大多数情况下，V8 下的数组是「顺序存储结构」，所以我们就假装 V8 的数组使用的是「顺序存储结构」吧！（-_-! 心虚） javascript 开发需要「链表」吗？自问自答大多数情况下 javascript 开发关心的是「数据的逻辑结构」而非「数据的存储结构」，似乎「链表」跟 javascript 开发没什么关系。But…「链表」在一些情况下能有效提升代码的性能，特别是在H5游戏的过程中。 假设有一个业务需要高频率地向一张「线性表科普」插入或删除节点。通常笔者会用数组表示「线性表」，因为 javascript 的数组有一系列成熟好用的 APIs （如：unshift / push / shift / pop / splice 等）可以完成插入与删除节点的操作。但是数组（顺序存储结构）的 unshift &amp; shift &amp; splice 的算法时间复杂度是 O(n) ，这情况可能「链表」是更好的选择。 图解链表先看一下最简单的单向链表： 往链表里插入一个节点： 剔除链表里的节点： 往链表里插入一条链表： 剪除链表的一段切片： 通过上面的图示，可以很清晰地了解到单链表的优势：插入节点或链表片段的算法时间复杂度为O(2)；删除节点或链表片段的算法时间复杂度为O(1) 实现双向链表「单向链表」效率虽然高，不过局限性比较大。所以笔者想实现的是「双向链表」。双向链表插入节点或链表的算法时间复杂度为 O(4)，删除节点或链表片段的算法时间复杂度为O(2)。双向链表的结构如下： 节点指针 ——「前驱」与「后继」 链表指针 —— 「头指针」、「尾指针」和「游标指针」 用一个匿名对象作为链表上的节点，如下伪代码：1234567function generateNode(data) &#123; return &#123; data: data, // 数据域 next: null, // 前驱指针 prev: null // 后继指针 &#125; &#125; 声明变量 HEAD, TAIL, POINTER &amp; length 分别指代「头指针」，「尾指针」，「游标指针」和 「链表长度」，那么构建一个双向链表如下伪代码： 1234567891011121314151617181920let HEAD, TAIL, POINTER, length = 0; // 创建一条长度为5的双向链表[0, 1, 2, 3, 4].forEach((data, index, arr) =&gt; &#123; let node = generateNode(data); // 第一个节点 if(index === 0) &#123; HEAD = node; &#125; else &#123; // 指定前驱后继指针 [node.prev, POINTER.next] = [POINTER, node]; // 最后一个节点 index === arr.length - 1 &amp;&amp; (TAIL = node) &#125; // 指向当前节点 POINTER = node; ++length; &#125;); // 游标指针回退到头部POINTER = HEAD; 链表结构本身是个很简单的结构，20行左右代码可以完成双向链表数据结构的构建。 定制 APIs上一节虽然实现了「双向链表」的数据结构，但链表还处在很原始的状态，操作起来比较麻烦，为了方便操作链表得为链表量身定做一套 APIs。数组有一系列成熟且好用的 APIs，笔者想借鉴数组的 APIs 为链表定制以下的 APIs: Name Detail Name Detail Name Detail Name Detail shift 参见数组 unshift 参见数组 pop 参见数组 push 参见数组 slice 参见数组 splice 参见数组 concat 参见数组 reverse 参见数组 sort 参见数组 indexOf 参见数组 length[属性] 参见数组 - - at 指针定位 prev 指针前移 next 指针后退 curr 当前指针 first 头节点 last 尾节点 remove 删除节点 clone 克隆链表 insertAfter 插入节点 insertBefore 插入节点 insertChainAfter 插入链表 insertChainBefore 插入链表 HEAD[属性] 头指针 TAIL[属性] 尾指针 setHead 重置头指针 setTail 重置尾指针 POINTER[属性] 游标指针（当前位置） setPointer 设置当前指针 - - - - 上表与数组同名的 APIs，表示用法与功能与数组一样。 为了突显「链表性」笔者添加了四个 insert*。insert* 的作用是向主链表指定位置插入节点或链表。APIs 不小心被笔者写多了，这里就不展开介绍它们的实现过程了。有兴趣的同学可以移步：https://github.com/leeenx/es6-utils/blob/master/modules/Chain_v2.js 循环链表笔者以往都是用数组来模拟循环链表，如下：12345678910Array.prototype.next = function() &#123; var cur = this[0]; this.push(this.shift()); return cur;&#125;var arr = [1, 2, 3, 4, 5]; var count = 0; while(count++&lt;20) &#123; console.log(arr.next());&#125; 有了 Chain 类后，可以直接这样写： 123456let circle = new Chain([1, 2, 3, 4, 5]); // 链表头咬尾circle.TAIL.next = circle.HEAD; for(let i = 0; i &lt; 20; ++i) &#123; console.log(chain.next()); &#125; 结语近期有些同学在问笔者，使用 Chain 类真的可以提升性能吗？这个需要分情况，如果是比较长的「线性表」做高频的「删除」或「插入」操作，自然是使用 Chain 有算法上的优势。但是，对于短的「线性表」来说，使用数组更快一些，因为 V8 的数组性能相当高，笔者认为小于 200 的「线性表」都可以直接使用数组。 本文实现的 Chain 类托管在：https://github.com/leeenx/es6-utils/blob/master/modules/Chain_v2.js 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。 .post-content sup a { vertical-align: unset; }","pubDate":"Fri, 13 Oct 2017 14:30:48 GMT","guid":"https://aotu.io/notes/2017/10/13/make-a-chain-class/","category":"Web开发"},{"title":"wxapp-market 小程序营销组件","link":"https://aotu.io/notes/2017/09/28/wxapp-market/","description":"介绍wxapp-market 是凹凸实验室推出的一款基于微信小程序的营销组件，用于快速开发营销玩法类小程序项目页面，包含大转盘、刮刮乐、老虎机、水果机、九宫格翻纸牌、摇一摇、手势解锁等多种营销组件。 项目地址：https://github.com/o2team/wxapp-market 特性 基于小程序 WXML 提供模板（template）模块化开发 简单好用、易扩展 支持多种营销玩法 预览可通过微信web开发者工具，进行预览体验 快速上手拉取仓库1git clone git@github.com:o2team/wxapp-market.git 查看组件文件 大转盘 (Big wheel) : /components/wheel/ 刮刮乐 (Scratch tickets) : /components/scratch/ 老虎机 (Slot machine) : /components/slotMachine/ 水果机 (Fruit machine) : /components/fruitMachine/ 九宫格翻纸牌 (Grid card) : /components/card/ 摇一摇 (Shake) : /components/shake/ 手势解锁 (Gesture lock) : /components/lock/ 引入组件引入对应所需组件，实例组件对象、配置参数即可。如大转盘组件： WXSS中引用样式：@import &quot;../../components/wheel/wheel.wxss&quot; WXML中引用结构：&lt;import src=&quot;../../components/wheel/wheel.wxml&quot;/&gt; JS中引用：import Wheel from &quot;../../components/wheel/wheel.js&quot; 12345678910new Wheel(this,&#123; areaNumber: 8, //抽奖间隔 speed: 16, //转动速度 awardNumer: 2, //中奖区域从1开始 mode: 1, //1是指针旋转，2为转盘旋转 callback: (idx, award) =&gt; &#123; //结束回调 &#125;&#125;) 更多使用说明，请阅读文档 wxapp-market 结语wxapp-market 是希望帮助开发者能够更快、更低门槛地开发出含营销功能的微信小程序，同时希望与众多开发者一起打造维护好用、易扩展的小程序营销组件库。 欢迎各位端友使用 wxapp-market，如果你在使用过程中遇到问题，或者有好的建议，欢迎给我们提 Issue 或者 Pull Request。","pubDate":"Thu, 28 Sep 2017 12:03:25 GMT","guid":"https://aotu.io/notes/2017/09/28/wxapp-market/","category":"Web开发"},{"title":"实现 setTimeout & setInterval 暂停的方案","link":"https://aotu.io/notes/2017/09/25/manage-setTimeout-an-setInterval/","description":"在管理 setTimeout &amp; setInterval 这两个 APIs 时，笔者通常会在顶级（全局）作用域创建一个叫 timer 的对象，在它下面有两个数组成员 —— {sto, siv}，用它们来分别存储需要管理的 setTimeoutID / setIntervalID。如下： 1234var timer = &#123; sto: [], siv: []&#125;; 在使用 setTimeout / setInterval 的时候，这样调用：12345678// 标记 setTimeoutIDtimer.sto.push( setTimeout(function() &#123;console.log(\"3s\")&#125;, 3000); ); // 标记 setIntervalIDtimer.siv.push( setInterval(function() &#123;console.log(\"1s\")&#125;, 1000)); 在页面需要 clearTimeout \\ clearInterval 的时候，这样调用： 1234// 批量清除 setTimeouttimer.sto.forEach(function(sto) &#123;clearTimeout(sto)&#125;); // 批量清除 setIntervaltimer.siv.forEach(function(siv) &#123;clearInterval(siv)&#125;); 暂停 &amp; 恢复近段时间，笔者发现很多业务都需要「暂停」和「恢复」setTimeout &amp; setInterval 的功能，而仅靠原生的四个 APIs（setTimeout / setIntervale / clearTimeout / clearInterval）是不够用的。于是，笔者对 timer 进行了扩展，使它具备了「暂停」和「恢复」的功能，如下： 1234// 暂停所有的 setTimeout &amp; setIntervaltimer.pause(); // 恢复所有的 setTimeout &amp; setIntervaltimer.resume(); 扩展后的 timer对象下面挂载6个基础的 APIs。 setTimeout setInterval clearTimeout clearInterval pause resume 使用 timer.set* &amp; timer.clear* 来代替原生的 set* &amp; clear*。笔者把扩展后的 timer 托管在 GitHub 仓库上，有兴趣的同学可以移步：https://github.com/leeenx/timer CreateJS 的启发在使用 CreateJS 开发一些项目的过程中，笔者发现通过设置 createjs.Ticker.paused = true / false，可以暂停/恢复 createjs.Tween 上的动画。于是笔者借用 createjs.Tween 模拟了 setTimeout &amp; setInterval 的功能，如下：12345678// setTimeoutcreatejs.setTimeout = function(fn, delay) &#123; createjs.Tween.get().wait(delay).call(fn);&#125;//setIntervalcreatejs.setInterval = function(fn, delay) &#123; createjs.Tween.get().wait(delay).call(fn).loop = 1; &#125; 具体的代码笔者托管在：createjs.timer。其实就是在 createjs 对象下挂载四个 APIs: setTimeout setInterval clearTimeout clearInterval 使用方法与原生的 setTimeout &amp; setInterval 一样，如下：12let siv = createjs.setInterval(() =&gt; console.log(\"1s\"), 1000);createjs.setTimeout(() =&gt; createjs.clearInterval(siv), 5000); 时间轴驱动的 timercreatejs.timer 在 CreateJS 项目的开发给笔者带来了极大的便利，但是它必须依赖 createjs.Tween 模块。于是笔者就在思考能否创建一个跟第三方框架无关并且又可以在第三方框架上使用的 timer。 createjs.Ticker.paused 为什么能暂停 createjs.Tween 上的动画的？createjs.Tween 中每一个动画都有一条自己的时间轴，这条时间轴是通过 createjs.Ticker 来驱动的；当 createjs.Ticker 被暂停后，createjs.Tween 中的每个动画的时间轴也会失去动力而暂停下来。 createjs.Ticker 的作用是提供一个刷新 canvas 画面帧频，通常是使用 requestAnimationFrame or setInterval 来实现的。如果 timer 内部存在一条时间轴，这条时间轴由第三方驱动，那么 timer 就可以与第三方框架状态同步了。 笔者是这样设计 timer 的结构： queue —— 存放 setTimeout or setInterval 的队列； updateQueue —— 驱动 queue 的内部 API； update —— 外部接口，用于对接第三方 Ticker。 实现的伪代码如下： 123456789101112131415161718192021222324/* @queue 成员的结构如下： &#123; fn: fn, // 回调函数 type: \"timeout or interval\", // 类型 elapsed: 0, // 时间轴进度 delay: delay // 目标时长 &#125;*/let queue = new Map(); function updateQueue(delta) &#123; queue.forEach((item, id) =&gt; &#123; item.elapsed += delta; if(item.elapsed &gt;= item.delay) &#123; item.fn(); // 从 queue 中删除 setTimeout 成员，interval 成员继续循环 item.type === \"timeout\" ? delete(id) : (item.elapsed = 0); &#125; &#125;); &#125;// 对外接口this.update = function(delta) &#123; updateQueue(delta); &#125; timer 的具体实现可以参考：https://github.com/leeenx/es6-utils#timer timer 与 CreateJS 一起使用：123456// es6 代码import timer from './modules/timer'; // 统一 tickercreatejs.Ticker.addEventListener(\"tick\", function(e) &#123; e.paused || timer.update(e.delta); &#125;); timer 与 PIXI 一起使用：123456// es6 代码import timer from './modules/timer'; // 统一 tickerapp.ticker.add(\"tick\", function() &#123; timer.update(app.ticker.elapsedMS); &#125;); 附上 PIXI 的线上 DEMO，二维码如下： 总结感谢阅读完本文章的读者。本文仅代表个人观点，希望能帮助到有相关问题的朋友，如果本文有不妥之处请不吝赐教。","pubDate":"Mon, 25 Sep 2017 08:04:51 GMT","guid":"https://aotu.io/notes/2017/09/25/manage-setTimeout-an-setInterval/","category":"Web开发"},{"title":"H5游戏开发：贪吃蛇","link":"https://aotu.io/notes/2017/09/25/h5game-snake/","description":"贪吃蛇的经典玩法有两种： 积分闯关 一吃到底 第一种是笔者小时候在掌上游戏机最先体验到的（不小心暴露了年龄），具体玩法是蛇吃完一定数量的食物后就通关，通关后速度会加快；第二种是诺基亚在1997年在其自家手机上安装的游戏，它的玩法是吃到没食物为止。笔者要实现的就是第二种玩法。 MVC设计模式基于贪吃蛇的经典，笔者在实现它时也使用一种经典的设计模型：MVC（即：Model - View - Control）。游戏的各种状态与数据结构由 Model 来管理；View 用于显示 Model 的变化；用户与游戏的交互由 Control 完成（Control 提供各种游戏API接口）。 Model 是游戏的核心也是本文的主要内容；View 会涉及到部分性能问题；Control 负责业务逻辑。 这样设计的好处是： Model完全独立，View 是 Model 的状态机，Model 与 View 都由 Control 来驱动。 Model看一张贪吃蛇的经典图片。 贪吃蛇有四个关键的参与对象： 蛇（snake） 食物（food） 墙（bounds） 舞台（zone） 舞台是一个 m * n 的矩阵（二维数组），矩阵的索引边界是舞台的墙，矩阵上的成员用于标记食物和蛇的位置。 空舞台如下：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 食物（F）和蛇（S）出现在舞台上：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,F,0,0,0,0,0,0,0], [0,0,0,S,S,S,S,0,0,0], [0,0,0,0,0,0,S,0,0,0], [0,0,0,0,S,S,S,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 由于操作二维数组不如一维数组方便，所以笔者使用的是一维数组， 如下：123456789101112[ 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,F,0,0,0,0,0,0,0, 0,0,0,S,S,S,S,0,0,0, 0,0,0,0,0,0,S,0,0,0, 0,0,0,0,S,S,S,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,] 舞台矩阵上蛇与食物只是舞台对二者的映射，它们彼此都有独立的数据结构： 蛇是一串坐标索引链表； 食物是一个指向舞台坐标的索引值。 蛇的活动蛇的活动有三种，如下： 移动（move） 吃食（eat） 碰撞（collision） 移动蛇在移动时，内部发生了什么变化？ 蛇链表在一次移动过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点。用一个数组来代表蛇链表，那么蛇的移动就是以下的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next);&#125; 数组作为蛇链表合适吗？这是笔者最开始思考的问题，毕竟数组的 unshift &amp; pop 可以无缝表示蛇的移动。不过，方便不代表性能好，unshift 向数组插入元素的时间复杂度是 O(n)， pop 剔除数组尾元素的时间复杂度是 O(1)。 蛇的移动是一个高频率的动作，如果一次动作的算法复杂度为 O(n) 并且蛇的长度比较大，那么游戏的性能会有问题。笔者想实现的贪吃蛇理论上讲是一条长蛇，所以笔者在本文章的回复是 —— 数组不适合作为蛇链表。 蛇链表必须是真正的链表结构。链表删除或插入一个节点的时间复杂度为O(1)，用链表作为蛇链表的数据结构能提高游戏的性能。javascript 没有现成的链表结构，笔者写了一个叫 Chain 的链表类，Chain 提供了 unshfit &amp; pop。以下伪代码是创建一条蛇链表： 1let snake = new Chain(); 由于篇幅问题这里就不介绍 Chain 是如何实现的，有兴趣的同学可以移步到: https://github.com/leeenx/es6-utils#chain 吃食 &amp; 碰撞「吃食」与「碰撞」区别在于吃食撞上了「食物」，碰撞撞上了「墙」。笔者认为「吃食」与「碰撞」属于蛇一次「移动」的三个可能结果的两个分支。蛇移动的三个可能结果是：「前进」、「吃食」和「碰撞」。 回头看一下蛇移动的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next);&#125; 代码中的 next 表示蛇头即将进入的格子的索引值，只有当这个格子是0时蛇才能「前进」，当这个格子是 S 表示「碰撞」自己，当这个格子是 F表示吃食。 好像少了撞墙？笔者在设计过程中，并没有把墙设计在舞台的矩阵中，而是通过索引出界的方式来表示撞墙。简单地说就是 next === -1 时表示出界和撞墙。 以下伪代码表示蛇的整上活动过程：123456789101112// B 表示撞墙let cell = -1 === next ? B : zone[next];switch(cell) &#123; // 吃食 case F: eat(); break; // 撞到自己 case S: collision(S); break; // 撞墙 case B: collision(B): break; // 前进 default: move;&#125; 随机投食随机投食是指随机挑选舞台的一个索引值用于映射食物的位置。这似乎很简单，可以直接这样写：12// 伪代码food = Math.random(zone.length) &gt;&gt; 0; 如果考虑到投食的前提 —— 不与蛇身重叠，你会发现上面的随机代码并不能保证投食位置不与蛇身重叠。由于这个算法的安全性带有赌博性质，且把它称作「赌博算法」。为了保证投食的安全性，笔者把算法扩展了一下：1234567// 伪代码function feed() &#123; let index = Math.random(zone.length) &gt;&gt; 0; // 当前位置是否被占用 return zone[index] === S ? feed() : index;&#125;food = feed(); 上面的代码虽然在理论上可以保证投食的绝对安全，不过笔者把这个算法称作「不要命的赌徒算法」，因为上面的算法有致命的BUG —— 超长递归 or 死循环。 为了解决上面的致命问题，笔者设计了下面的算法来做随机投食：1234567891011121314151617181920// 伪代码function feed() &#123; // 未被占用的空格数 let len = zone.length - snake.length; // 无法投食 if(len === 0) return ; // zone的索引 let index = 0, // 空格计数器 count = 0, // 第 rnd 个空格子是最终要投食的位置 rnd = Math.random() * count &gt;&gt; 0 + 1; // 累计空格数 while(count !== rnd) &#123; // 当前格子为空，count总数增一 zone[index++] === 0 &amp;&amp; ++count; &#125; return index - 1;&#125;food = feed(); 这个算法的平均复杂度为 O(n/2)。由于投食是一个低频操作，所以 O(n/2)的复杂度并不会带来任何性能问题。不过，笔者觉得这个算法的复杂度还是有点高了。回头看一下最开始的「赌博算法」，虽然「赌博算法」很不靠谱，但是它有一个优势 —— 时间复杂度为 O(1)。 「赌博算法」的靠谱概率 = (zone.length - snake.length) / zone.length。snake.length 是一个动态值，它的变化范围是：0 ~ zone.length。推导出「赌博算法」的平均靠谱概率是： 「赌博算法」平均靠谱概率 = 50% 看来「赌博算法」还是可以利用一下的。于是笔者重新设计了一个算法：12345678910// 伪代码function bet() &#123; let rnd = Math.random() * zone.length &gt;&gt; 0; return zone[rnd] === 0 ? rnd : -1;&#125;function feed() &#123; ...&#125;food = bet();if(food === -1) food = feed(); 新算法的平均复杂度可以有效地降低到 O(n/4)，人生有时候需要点运气 : )。 View在 View 可以根据喜好选择一款游戏渲染引擎，笔者在 View 层选择了 PIXI 作为游戏游戏渲染引擎。 View 的任务主要有两个： 绘制游戏的界面； 渲染 Model 里的各种数据结构 也就是说 View 是使用渲染引擎还原设计稿的过程。本文的目的是介绍「贪吃蛇」的实现思路，如何使用一个渲染引擎不是本文讨论的范畴，笔者想介绍的是：「如何提高渲染的效率」。 在 View 中显示 Model 的蛇可以简单地如以下伪代码：12345678910// 清空 View 上的蛇view.snake.clean();model.snake.forEach( (node) =&gt; &#123; // 创建 View 上的蛇节点 let viewNode = createViewNode(node); // 并合一条新蛇 view.snake.push(viewNode); &#125;); 上面代码的时间复杂度是 O(n)。上面介绍过蛇的移动是一个高频的活动，我们要尽量避免高频率地运行 O(n) 的代码。来分析蛇的三种活动：「移动」，「吃食」，「碰撞」。首先，Model 发生了「碰撞」，View 应该是直接暂停渲染 Model 里的状态，游戏处在死亡状态，接下来的事由 Control 处理。Model 中的蛇（链表）在一次「移动」过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点；蛇（链表）在一次「吃食」过程中只做一件事：向表头插入一个新节点。 如果在 View 中对 Model 的蛇链表做差异化检查，View 只增量更新差异部分的话，算法的时间复杂度即可降低至 O(1) ~ O(2) 。以下是优化后的伪代码： 12345678910111213141516171819202122232425let snakeA = model.snake, snakeB = view.snake;// 增量更新尾部while(snakeB.length &lt;= snakeA.length) &#123; headA = snakeA.next(); // 头节点匹配 if(headA.data === headB.data) break; // 不匹配 else &#123; // 向snakeB插入头节点 if(snakeA.HEAD === headA.index) &#123; snakeB.unshift(headA.data); &#125; // 向snakeB插入第二个节点 else snakeB.insertAfter(0, headA.data); &#125;&#125;// 增量更新头部let tailA = snakeA.last(), tailB;while(snakeB.length !== 0) &#123; tailB = snakeB.last(); // 尾节点匹配 if(tailA.data === tailB.data) break; // 不匹配 else snakeB.pop();&#125; ControlControl 主要做 3 件事： 游戏与用户的互动 驱动 Model 同步 View 与 Model 「游戏与用户的互动」是指向外提供游戏过程需要使用到的 APIs 与 各类事件。笔者规划的 APIs 如下： name type deltail init method 初始化游戏 start method 开始游戏 restart method 重新开始游戏 pause method 暂停 resume method 恢复 turn method 控制蛇的转向。如：turn(“left”) destroy method 销毁游戏 speed property 蛇的移动速度 事件如下： name detail countdown 倒时计 eat 吃到食物 before-eat 吃到食物前触发 gameover 游戏结束 事件统一挂载在游戏实例下的 event 对象下。1snake.event.on(\"countdown\", (time) =&gt; console.log(\"剩余时间：\", time)); 「驱动 Model 」只做一件事 —— 将 Model 的蛇的方向更新为用户指定的方向。「同步 View 与 Model 」也比较简单，检查 Model 是否有更新，如果有更新通知 View 更新游戏界面。 结语下面是本文介绍的贪吃蛇的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/snake 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。","pubDate":"Mon, 25 Sep 2017 02:19:06 GMT","guid":"https://aotu.io/notes/2017/09/25/h5game-snake/","category":"H5游戏开发"},{"title":"whistle 使用实践","link":"https://aotu.io/notes/2017/08/29/an-introduction-to-whistle/","description":"whistle 是一款用 Node 实现的跨平台的 Web 调试代理工具，支持查看修改 http(s)、Websocket 连接的请求和响应内容。简而言之就是 Node 版的 Fiddler、Charles，不过这个工具能远比后两者更加适合 Web 开发者、使用更简单、功能也更加实用，而笔者使用了 1 个月后发现完全可以代替 Fiddler、Charles。 安装&amp;运行whistle 运行时会监听一个端口，把 Chrome（或其他程序）转发到该端口的数据处理后再返回，而在 Chrome 里则通过一个代理层把请求转发到相应端口。 Chrome 插件：whistle for Chrome Node 端的 CI 工具 12345# 安装sudo npm i -g whistle# 运行w2 start 详见：安装方法 最后，打开 http://local.whistlejs.com/#network 即可进入控制台界面 常用功能一览 绑定host 12# 说明：相当于浏览器层的host文件，如果找不到再去查找本机的host文件192.168.0.1 mydomain.com 替换请求 12# 说明：请求百度的时候会返回京东的页面内容https://m.baidu.com https://wq.jd.com/ 修改返回码 12# 说明：使 http 返回 404https://m.baidu.com statusCode://404 往 html 插入脚本 123# 说明：会在网页最后以 script 标签的形式插入，花括号的值是内置编辑器保存的文件，在主菜单 “Value” 下可找到https://wq.jd.com js://&#123;test.js&#125;https://wq.jd.com js:///Users/myname/test/test.js 往 html 插入样式 12# 说明：在网页里以 style 标签的形式插入https://wq.jd.com css://&#123;test.css&#125; 文本类请求 append 内容、替换返回内容 1234# 说明：会把内容 append 到请求后面http://mydomain.com/style.css resAppend://&#123;myAppend.css&#125;# 说明：完全替换请求内容http://mydomain.com/style.css resBody://&#123;myResBody.css&#125; weinre 调试页面 12# 说明：为 https://wq.jd.com 页面快速添加一个 weinre 调试脚本，点击 http://local.whistlejs.com/weinre/client/#debug_mypage 或界面主菜单 “Weinre” 可打开 inspect 界面调试该页面https://wq.jd.com weinre://debug_mypage 更多的使用方法可以参考 whistle 协议列表 小结从上面可以看出 whistle 的大致工作流程： 配置需要修改的 url 地址 编写\u001c URI 协议，如 statusCode:// 编写协议对应的参数，如 statusCode://404 可以看出 whistle 的操作都是通过文本配置去实现，比较符合程序员的思维。 whistle 可操作的资源的 request 、respond 的 header、 body， 其中 header 里面的 query 、ua 、 cookie、status Code 等数据对前端来说非常熟悉， 也都有相应的协议去操作这些数据。 另外， whistle 很多操作协议都是针对前端开发友好的，比如 html、 js 、css 等类型的请求的修改协议对于前端程序猿来说都非常亲切。 使用建议1. 代替本地的 host 文件由于 whistle 兼容操作系统的 host 语法格式，所以在浏览器层面的 host 配置可轻松代替本地的 host 文件。这样做的主要好处是无缓存，切换时生效更快。 有一个技巧就是在 “Rules” 界面下，可配多套 host 配置，比如 dev、gamma 等满足开发需求。 2. 多终端代理 手机的 wifi 设置里，打开代理，连接本机 ip 和 8899 端口即可查看手机的网页请求 电脑其余程序的代理设置，也可通过本机 ip 和 8899 端口的形式使用 whistle 查看请求，比如微信 web 开发者工具\u001c 注意以上操作均需要在同一个局域网内 3. 转换 http 协议转发协议+域名转发，轻松本地模拟 https ，访问线上的 https 域名实际上指向的是本地的 http 调试地址。1https://wq.jd.com http://localhost:9000 注意，涉及到 https 的请求都需要您的电脑和手机等都安装 whistle 提供的证书，详情可看文档。 4. mock 数据whistle 提供了一个强大的 mock 数据的插件，强大之处是可以结合 js 语句 + mock 语法去生成数据。举一个简单的例子说明用法： 先安装插件：1npm i -g whistle.vase 在 “Plugins” 菜单打开 vase 的界面，新建一个名字为 “mock_json_demo” 的配置，并选择模板为 mock 。输入如下内容：1234567&#123; \"list|5\": [&#123; \"name\": \"@string\", \"avatar\": \"http://lorempixel.com/100/100/\", \"id|+1\": 10000 &#125;]&#125; 不熟悉 mock 语法的朋友可以到这里了解一下 在 “Rules” 下配置一条 vase 的规则：1http://mock.local/data.json vase://mock_json_demo 打开测试地址 http://mock.local/data.json ，即可看到模拟的数据。 有读者可能会问，如果想更自由度更高一点，用 js 去生成数据是否可行？ 当然可行，vase 提供了一种 “script” 模板可实现这种需求，里面可以写一些简单的 javascript API，还提供了 req（request）等内置数据对象，可以获取如请求的 headers、method、body、query、url 等数据。 既然这些数据都有了，是不是可以搞事情了？我有一个大胆的想法，请看下面的例子： 在 vase 界面新建一个名为 “json_engine_script” 数据模板，并选择 “script” 模板引擎。12345678910111213var json = merge(&#123; page: req.query.pi, // 取url查询参数的分页字段，加到要返回的数据里，达到模拟分页数据的效果 total: 60&#125;, render('mock_json_demo', null, 'mock')); // render 可以渲染上文提到名为“mock_json_demo”的数据模板，返回一个jsonif (req.query.callback) &#123; // 如果查询参数带了callback，则返回jsonp out(header('content-type', 'application/javascript; charset=utf8')); var json_text = join([req.query.callback+'(', json, ')']); // join是内置方法，可合并一组数据 out(json_text); // 向body输出数据&#125; else &#123; // 没有callback则返回json out(header('content-type', 'application/json; charset=utf8')); out(json);&#125; 在 “Rules” 输入以下配置：123http://mock.local/data.json vase://json_engine_script# 注释掉上一条配置# http://mock.local/data.json vase://mock_json_demo 打开 http://mock.local/data.json?callback=cb&amp;pi=1 ，可尝试改变、删除 callback、pi 参数，会发现返回的数据会随之改变。 至此就完成了一个简单的、有一定扩展性的 restful 数据接口模拟。 5. mock &amp; more在现有的开发工作流里，在需求开发完毕进入测试后，相信有不少团队都是需要测试人员单独模拟数据去测试页面功能。所以在开发阶段的 mock 数据、whistle rules 是不是可以直接共享给测试去使用了呢？因为纯文本配置的数据共享起来毕竟比较方便。 如果项目迭代比较快，觉得共享多份 mock 配置数据不方便，是否可以单独搞个 mock server（市面上已有类似服务比如 easy mock，我们团队也有一个好用的文档管理 &amp; mock server），whistle 只进行请求转发，而开发与测试人员只需要共享 whistle rules 即可？ 结语总体来说 whistle 的玩法还是蛮多的，入门也比较简单，不过也是依然缺少一些功能，比如调试 websocket\u001c、图片 等的能力，也缺少一些账户系统 &amp; 共享配置的能力，希望作者以后能够考虑完善一下这些功能吧，使这个工具更加好玩。 参考资料：whistle 文档 https://avwo.github.io/whistle/ vase 文档 https://github.com/whistle-plugins/whistle.vase mock 文档 https://github.com/nuysoft/Mock/wiki","pubDate":"Tue, 29 Aug 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/08/29/an-introduction-to-whistle/","category":"Web开发"},{"title":"Three.js 现学现卖","link":"https://aotu.io/notes/2017/08/28/getting-started-with-threejs/","description":"引言 三维计算机图形和二维计算机图形的不同之处在于计算机存储了几何数据的三维表示，其用于计算和绘制最终的二维图像。——《3D computer graphics》 随着 WebGL 标准的快速推进，越来越多团队尝试在浏览器上推出可交互的 3D 作品。相较于二维场景，它更能为用户带来真实和沉浸的体验。 然而 OpenGL 和 WebGL（基于 OpenGL ES） 都比较复杂，Three.js 则更适合初学者。本文将分享一些 Three.js 的基础知识，希望能让你能有所收获。 当然，分享的知识点也不会面面俱到，想更深入的学习，还得靠大家多看多实践。另外，为了控制篇幅，本文更倾向于通过案例中的代码和注释进行阐述一些细节。 若想系统学习，笔者认为看书是一个不错的选择： Three.js开发指南（原书第2版） 购买链接&gt;&gt; 尽管由于 Three.js 的不断迭代，书本上的某些 API 已改变（或弃用），甚至难免还有一些错误，但这些并不影响整体的阅读。 Canvas 2D如引言中说道，3D 图像在计算机中最终以 2D 图像呈现。因此，渲染模式只是作为一个载体。下面我们用 JavaScript（无依赖） 在 Canvas 2D 渲染一个在正视图/透视图中的立方体。 正视图中的立方体： See the Pen 3D Orthographic View by SitePoint (@SitePoint) on CodePen. 透视图中的立方体： See the Pen 3D Perspective View by SitePoint (@SitePoint) on CodePen. 若要将三维图形渲染在二维屏幕上，需要将三维坐标以某种方式转为二维坐标。但对于更复杂的场景，大量坐标的转换和阴影等耗性能操作无疑需要 Web 提供更高效的渲染模式。 另外，想了解上述两个案例的实现原理，可查看译文：《用 JavaScript 构建一个3D引擎》。 WebGLWebGL（Web Graphics Library）在 GPU 中运行。因此需要使用能够在 GPU 上运行的代码。这样的代码需要提供成对的方法（其中一个叫顶点着色器， 另一个叫片段着色器），并且使用一种类 C/C++ 的强类型语言 GLSL（OpenGL Shading Language)。 每一对方法组合起来称为一个 program（着色程序）。 顶点着色器的作用是计算顶点的位置。根据计算出的一系列顶点位置，WebGL 可以对点、线和三角形在内的一些图元进行光栅化处理。当对这些图元进行光栅化处理时需要使用片段着色器方法。片段着色器的作用是计算出当前绘制图元中每个像素的颜色值。 用 WebGL 绘制一个三角形： See the Pen WebGL - Fundamentals by Jc (@JChehe) on CodePen. 查看上述案例的代码实现后，我们发现绘制一个看似简单的三角形其实并不简单，它需要我们学习更多额外的知识。 因此，对于刚入门的开发者来说，直接使用 WebGL 来绘制并拼装出几何体是不现实的。但我们可以在了解 WebGL 的基础知识后，再通过 Three.js 这类封装后的库来现实我们的需求。 Three.js打开 Three.js 官方文档 并阅览左侧的目录，发现该文档对初学者并不友好。但相对于其他资料，它提供了最新的 API 说明，尽管有些描述并不详细（甚至需要在懂 WebGL 等其他知识的前提下，才能了解某个术语的意思）。下面提供两个 Three.js 的相关图片资料，希望它们能让你对 Three.js 有个整体的认识： Three.js 文档结构：图片来自&gt;&gt; Three.js 核心对象结构和基本的渲染流程：图片来自&gt;&gt; Three.js 的基本要素我们先通过一个简单但完整的案例来了解 Three.js 的基本使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 引入 Three.js 库&lt;script src=\"https://unpkg.com/three\"&gt;&lt;/script&gt;function init () &#123; // 获取浏览器窗口的宽高，后续会用 var width = window.innerWidth var height = window.innerHeight // 创建一个场景 var scene = new THREE.Scene() // 创建一个具有透视效果的摄像机 var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 800) // 设置摄像机位置，并将其朝向场景中心 camera.position.x = 10 camera.position.y = 10 camera.position.z = 30 camera.lookAt(scene.position) // 创建一个 WebGL 渲染器，Three.js 还提供 &lt;canvas&gt;, &lt;svg&gt;, CSS3D 渲染器。 var renderer = new THREE.WebGLRenderer() // 设置渲染器的清除颜色（即背景色）和尺寸。 // 若想用 body 作为背景，则可以不设置 clearColor，然后在创建渲染器时设置 alpha: true，即 new THREE.WebGLRenderer(&#123; alpha: true &#125;) renderer.setClearColor(0xffffff) renderer.setSize(width, height) // 创建一个长宽高均为 4 个单位长度的立方体（几何体） var cubeGeometry = new THREE.BoxGeometry(4, 4, 4) // 创建材质（该材质不受光源影响） var cubeMaterial = new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;) // 创建一个立方体网格（mesh）：将材质包裹在几何体上 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置网格的位置 cube.position.x = 0 cube.position.y = -2 cube.position.z = 0 // 将立方体网格加入到场景中 scene.add(cube) // 将渲染器的输出（此处是 canvas 元素）插入到 body 中 document.body.appendChild(renderer.domElement) // 渲染，即摄像机拍下此刻的场景 renderer.render(scene, camera)&#125;init() 在线案例： See the Pen threejs-blog-01-hello-world by Jc (@JChehe) on CodePen. 看完上述案例代码后，你可能会产生以下几个疑问： Three.js 的单位是什么？ 坐标系的位置和指向是？ 具有透视效果的摄像机的参数含义是？ Mesh 的作用是？ 下面我们逐一回答： 1. Three.js 的单位是什么？ 答：Three.js 基于 OpenGL，那我们从 OpenGL 文档看到这么一句话： “The preceding paragraph mentions inches and millimeters - do these really have anything to do with OpenGL? The answer is, in a word, no. The projection and other transformations are inherently unitless. If you want to think of the near and far clipping planes as located at 1.0 and 20.0 meters, inches, kilometers, or leagues, it’s up to you. The only rule is that you have to use a consistent unit of measurement. Then the resulting image is drawn to scale.” ——《OpenGL Programming Guide》中文：前面段落提及的英寸和毫米真的和 OpenGL 有关系吗？没有。投影和其它变换在本质上都是无单位的。如果你想把近距离和远距离的裁剪平面分别放置在 1.0 和 20.0 米/英寸/千米/里格，这取决于你。这里唯一的要求是你必须使用统一的测量单位，然后按比例绘制最终图像。 2. 坐标系的位置和指向是？ 答：Three.js 的坐标系是遵循右手坐标系，如下图： 右手坐标系 坐标系的原点在画布中心（canvas.width / 2, canvas.height / 2）。我们可以通过 Three.js 提供的 THREE.AxisHelper() 辅助方法将坐标系可视化。 RGB颜色分别代表 XYZ 轴： See the Pen threejs-blog-02-axis by Jc (@JChehe) on CodePen. 另外，补充一点：对于旋转 cube.rotation 正值是逆时针旋转，负值是顺时针旋转。 3. 具有透视效果的摄像机的参数含义是？答： THREE.PerspectiveCamera(fov, aspect, near, far) 具有 4 个参数，具体解释如下： 参数 描述 fov fov 表示视场，即摄像机能看到的视野。比如，人类有接近 180 度的视场，而有些鸟类有接近 360 度的视场。但是由于计算机不能完全显示我们能够所看到的景象，所以一般会选择一块较小的区域。对于游戏而言，视场大小通常为 60 ~ 90 度。推荐默认值为：50 aspect 指定渲染结果的横向尺寸和纵向尺寸的比值。在我们的示例中，由于使用窗口作为输出界面，所有使用的是窗口的长宽比。推荐默认值：window.innerWidth / window.innerHeight near 指定从距离摄像机多近的距离开始渲染。推荐默认值：0.1 far 指定摄像机从它所处的位置开始能看到多远。若过小，那么场景中的远处不会被渲染；若过大，可能会影响性能。推荐默认值：1000 透视摄像机的参数图示 摄像机的 fov 属性指定了横向视场。基于 aspect 属性，纵向视场也就相应确定了。而近面和远面则指定了可视化区域的前后边界，即两者之间的元素才可能被渲染。 Three.js 还提供了其他 3 种摄像机：CubeCamera、OrthographicCamera、StereoCamera。 其中 OrthographicCamera 是正交投影摄像机，他不具有透视效果，即物体的大小不受远近距离的影响。 切换正交投影摄像机和透视摄像机： See the Pen switchCamera by Jc (@JChehe) on CodePen. 4. Mesh 的作用是？ 答：Mesh 好比一个包装工，它将『可视化的材质』粘合在一个『数学世界里的几何体』上，形成一个『可添加到场景的对象』。当然，创建的材质和几何体可以多次使用（若需要）。而且，包装工不止一种，还有 Points（点集）、Line（线/虚线） 等。 同一个几何体的多种表现形式： See the Pen multi-appearance by Jc (@JChehe) on CodePen. Three.js 提供的几何体从 Three.js 文档目录的 Geometries 可看到，Three.js 已为我们提供了很多现成的几何体，但如果对几何知识不常接触，可能就很难从它的英文名字联想到其实际的形状。下面我们将它们一次性罗列出来： Three.js 提供的 18 个几何体： See the Pen all-the-geometry by Jc (@JChehe) on CodePen. 目前 Three.js 一共提供了 22 个 Geometry，除了 EdgesGeometry、ExtrudeGeometry、TextGeometry、WireframeGeometry，上面涵盖 18 个，它们分别是底层的 planeGeometry 和以下 17 种（顺序与上述案例一一对应，下同）： BoxGeometry（长方体） CircleGeometry（圆形） ConeGeometry（圆锥体） CylinderGeometry（圆柱体） DodecahedronGeometry（十二面体） IcosahedronGeometry（二十面体） LatheGeometry（让任意曲线绕 y 轴旋转生成一个形状，如花瓶） OctahedronGeometry（八面体） ParametricGeometry（根据参数生成形状） PolyhedronGeometry（多面体） RingGeometry（环形） ShapeGeometry（二维形状） SphereGeometry（球体） TetrahedronGeometry（四面体） TorusGeometry（圆环体） TorusKnotGeometry（换面纽结体） TubeGeometry（管道） \\ \\ \\ 剩余的 TextGeometry、EdgesGeometry、WireframeGeometry、ExtrudeGeometry 我们单独拿出来解释： See the Pen the-remaining-geomtry by Jc (@JChehe) on CodePen. / TextGeometry / EdgesGeometry WireframeGeometry ExtrudeGeometry 如案例所示，EdgesGeometry 和 WireframeGeometry 更多地可能作为辅助功能去查看几何体的边和线框（三角形图元）。 ExtrudeGeometry 则是按照指定参数将一个二维图形沿 z 轴拉伸出一个三维图形。 TextGeometry 则需要从外部加载特定格式的字体文件（可在 typeface.js 网站上进行转换）进行渲染，其内部依然使用 ExtrudeGeometry 对字体进行拉伸，从而形成三维字体。另外，该类字体的本质是一系列类似 SVG 的指令。所以，字体越简单（如直线越多），就越容易被正确渲染。 以上就是目前 Three.js 提供的几何体，当然，这些几何体的形状也不仅于此，通过改变参数即能生成更多种类的形状，如 THREE.CircleGeometry 可生成扇形。 另外，通过 console.log 查看任意一个 geometry 对象可发现，在 Three.js 中的几何体基本上是三维空间中的点集（即顶点）和这些顶点连接起来的面组成的。以立方体为例（widthSegments、heightSegments、depthSegments 均为 1 时）： 一个立方体有 8 个顶点，每个顶点通过 x、y 和 z 坐标来定义。 一个立方体有 6 个面，而每个面都包含两个由 3 个顶点组成的三角形。 对于 Three.js 提供的几何体，我们不需要自己定义这些几何体的顶点和面，只需提供 API 指定的参数即可（如长方体的长宽高）。当然，你仍然可以通过定义顶点和面来创建自定义的几何体。如： 123456789101112131415161718192021222324252627282930var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1)]var faces = [ new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 6, 5), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 6, 4)]var geometry = new THREE.Geometry()geometry.vertices = verticesgeometry.faces = facesgeomtry.computeFaceNormals() 上述代码需要注意的点有： 创建面时顶点的顺序，因为顶点顺序决定了某个面是面向摄像机还是背向摄像机。顶点的顺序是逆时针则是面向摄像机，反之则是背向摄像机。 出于性能的考虑，Three.js 认为几何体在整个生命周期都不会更改。若出现更改（如某顶点的位置），则需要告诉 geometry 对象的顶点需要更新 geometry.verticesNeedUpdate = true。更多关于需要主动设置变量来开启更新的事项，可查看官方文档的 How to update things。 声音我们从文档目录中竟然发现有 Audio 音频对象，为什么 Three.js 不是游戏引擎，却带个音频组件呢？原来这个音频也是 3D 的，它会受到摄像机的距离影响： 声源离摄像机的距离决定着声音的大小。 声源在摄像机左右侧的位置分别决定着左右扬声器声音的大小。 我们可以到 官方案例 亲自体验一下 Audio 的效果。 常见的插件在 Three.js 的官方案例中，你几乎都能看到左右上角的两个常驻控件，它们分别是：JavaScript 性能监测器 stats.js 和可视化调参插件 dat.GUI。 stats.jsstats.js 为开发者提供了易用的性能监测功能，它目前支持四种模式： 帧率 每帧的渲染时间 内存占用量 用户自定义 dat.GUIdat.GUI 为开发者提供了可视化调参的面板，对参数调整的操作提供了极大的便利。 关于这两个插件的使用，请查看他们的官方文档或 Three.js 官方案例中的代码。 其他一些东西自适应屏幕（窗口）大小12345678910window.addEventListener('resize', onResize, false)function onResize () &#123; // 设置透视摄像机的长宽比 camera.aspect = window.innerWidth / window.innerHeight // 摄像机的 position 和 target 是自动更新的，而 fov、aspect、near、far 的修改则需要重新计算投影矩阵（projection matrix） camera.updateProjectionMatrix() // 设置渲染器输出的 canvas 的大小 renderer.setSize(window.innerWidth, window.innerHeight)&#125; 阴影阴影是增强三维场景效果的重要因素，但 Three.js 出于性能考虑，默认关闭阴影。下面我们来看看如何开启阴影的。 渲染器启用阴影 1renderer.shadowMap.enabled = true 指定哪个光源能产生阴影 12// 并不是所有类型的光源能产生投影，不能产生投影的光源有：环境光（AmbientLight）、半球光（HemisphereLight）spotLight.castShadow = true 指定哪个物体能投射阴影，哪个物体能接受阴影（在 CSS 中，我们都会认为只有背景接受阴影，毕竟它们都是平面） 123456// 平面和立方体都能接受阴影plane.receiveShadow = truecube.receiveShadow = true// 球体的阴影可以投射到平面和球体上sphere.castShadow = true 更改阴影质量 123456// 更改渲染器的投影类型，默认值是 THREE.PCFShadowMaprenderer.shadowMap.type = THREE.PCFSoftShadowMap// 更改光源的阴影质量，默认值是 512spotLight.shadow.mapSize.width = 1024 spotLight.shadow.mapSize.height = 1024 产生阴影： See the Pen shadow by Jc (@JChehe) on CodePen. 雾化效果雾化效果是指：场景中的物体离摄像机越远就会变得越模糊。 目前，Three.js 提供两种雾化效果：12345678910111213// Fog( hex, near, far )，线性雾化。// near 表示哪里开始应用雾化效果（摄像机为 0）// far 表示哪里的雾化浓度为 1。若某物体在该距离后，则其表现为雾的颜色。当雾的颜色和渲染器的背景色相同时，则表现为消失（实为颜色相同）。scene.fog = new THREE.Fog( 0xffffff, 0.015, 100 )// FogExp2( hex, density )，指数雾化// density 是雾化强度scene.fog = new THREE.FogExp2( 0xffffff, 0.01 )// 雾化效果默认是全局影响的，若某个材质不受雾化效果影响，则可为材质的 fog 属性设置为 false（默认值 true）var material = new THREE.Material(&#123; fog: false&#125;) 查看不同位置的立方体： See the Pen fog by Jc (@JChehe) on CodePen. Low Poly其实，对于前端开发来说，能做到用代码实现就要尽量不用外部加载的图片（纹理）来装饰物体就最好了。对于前面提及的几何体，其实只要发挥我们的创意，就能将不起眼的它们变得有魅力，如 Low Poly。 圣诞树： See the Pen Step Five by Matt Agar (@agar) on CodePen. 更多关于 Low Poly 风格的案例和学习资料： 圣诞树：https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/ 飞行者（The Aviator）小游戏：https://tympanus.net/codrops/2016/04/26/the-aviator-animating-basic-3d-scene-threejs/ Yakudoo’s Codepen：https://codepen.io/Yakudoo/ 渲染器剔除模式（Face culling）CSS3 有一个 backface-visibility 属性，它指定当元素背面朝向用户时，该元素是否可见。因为元素背面的背景颜色是透明的，所以当其可见时，就会显示元素正面的镜像。 而在 Three.js 中，材质默认只应用在正面（THREE.FrontSide），即当你旋转物体（或摄像机）查看物体的背面时，它会因为未被应用材质而变得透明（即效果与 CSS3 backface-visibility: hidden 一样）。因此，当你想让物体正反两面均应用材质，则需要在创建材质时声明 side 属性为 THREE.DoubleSide： 123var material = new THREE.MeshBasicMaterial(&#123; side: THREE.DoubleSide // 其他值：THREE.FrontSide（默认值）、THREE.BackSide&#125;) 当然，为几何体正反两面均应用材质时，会让渲染器做更多工作，从而影响性能。同理，对于 CSS3，若对动画性能有更高的追求，则可以尝试显示地为 transform 动画元素设置其背面不可见 backface-visibility: hidden;，这样也许能提高性能。 可你是否见过或想到过这样的一个应用场景： 3D 看房 当你旋转时，面向用户的墙都会变得透明，从而实现 360 度查看房子内部结构的效果。 剔除外部立方体正面： See the Pen Face culling by Jc (@JChehe) on CodePen. 上述案例会实时剔除外层立方体的正面，从而保证其内部可见。 这里其实涉及到 OpenGL 的 Face culling 的知识点。出于性能的考虑，Three.js 默认开启 Face culling 特性，且将剔除模式设置为 CullFaceBack（默认值），这样就可剔除对于观察者不可见的反面 。 因此，当我们将剔除模式设置为 CullFaceFront（剔除正面） 时，就会发生以上效果。一切看起来都是这么自然。其实仔细想想，就会发现有点不对劲。 假设一个面由正面和反面组成，那现在只剔除正面，那该面的反面不就显示出来了？答：其实正面还是反面是相对于观察者的，而不是说一个面由正面和反面组成。当然你也可以认为一个面是无限扁的，由正反两面组成，但只有面向观察者的一面才可见。 那现在被显示出来的面都是反面（相对于观察者），而这些反面并没有应用材质（side: THREE.BackSide 或 THREE.DoubleSide），那它不应该也是不可见的吗？答：笔者反复试验和查阅资料后，仍然没得出答案，若你知道原因麻烦告诉我哦。 关于 OpenGL 的 Face culling 更多知识，可阅读：《Learn OpenGL》。 粒子化对于粒子化效果，相信大家都不陌生。前段时间的 《腾讯的 UP2017》 就是应用 Three.js 实现粒子化效果的精彩案例。 对于 Three.js，实现粒子效果的方法有两种：THREE.Sprite( material ) 和 THREE.Points( geometry, material )。而且这两者都会一直面向摄像机（无论你旋转摄像机还是设置粒子的 rotation 属性）。 下面基于 THREE.Sprite 实现一个简单的 10 x 10 粒子效果（可拖拽旋转）： See the Pen sprite by Jc (@JChehe) on CodePen. 当粒子数量较小时，一般不会存在性能问题。但随着数量的增长，就会很快遇到性能瓶颈。此时，使用 THREE.Points 更为合适。因为 Three.js 不再需要管理大量 THREE.Sprite 对象，而只需管理一个 THREE.Points 对象。 下面我们用 THREE.Points 实现上一个案例的效果： See the Pen points by Jc (@JChehe) on CodePen. 从上述两个案例可看到，粒子默认形状是正方形。若想改变它的形状，则需要用到纹理。样式化粒子的纹理一般有两种方式：加载外部图片和 Canvas 2D 画布。 Canvas 2D 画布： See the Pen points-canvas by Jc (@JChehe) on CodePen. 加载外部图片： See the Pen points-img by Jc (@JChehe) on CodePen. 上一个案例中，我们加载了两个不同的纹理。由于 THREE.Points 的局限性（一个材质只能对应一种纹理），若想添加多个纹理，则需要创建相应个数的 THREE.Points 实例，而 THREE.Sprite 在此方面显得更灵活一些。 上述粒子效果都是我们手动设置各个粒子的具体位置，若想将特定形状通过粒子效果显示，则可以直接将该几何体（geometry）传入 THREE.Points( geometry, material ) 的第一个参数即可。 See the Pen points-models by Jc (@JChehe) on CodePen. 点击物体鼠标作为 PC 端（移动端中的触摸）的主要交互方式，我们经常会通过它来选择页面上的元素。而对于 Three.js，它没有类似 DOM 的层级关系，并且处于三维环境中，那么我们则需要通过以下方式来判断某对象是否被选中。12345678910111213141516function onDocumentMouseDown(event) &#123; var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5); vector = vector.unproject(camera); var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize()); var intersects = raycaster.intersectObjects([sphere, cylinder, cube]); if (intersects.length &gt; 0) &#123; console.log(intersects[0]); intersects[0].object.material.transparent = true; intersects[0].object.material.opacity = 0.1; &#125;&#125; 当点击鼠标时，上述代码会发生以下处理： 基于屏幕上的点击位置创建一个 THREE.Vector3 向量。 使用 vector.unproject 方法将屏幕上的点击位置转换成 Three.js 场景中的坐标。换句话说，就是将屏幕坐标转换成三维场景中的坐标。 创建 THREE.Raycaster。使用 THREE.Raycaster 可以向场景中发射光线。在下述案例中，从摄像机的位置（camera.position）向场景中鼠标的点击位置发射光线。 使用 raycaster.intersectObjects 方法来判断指定的对象中哪些被该光线照射到的。 上述最后一步会返回包含了所有被光线照射到的对象信息的数组（根据距离摄像机距离，由短到长排序）。数组的子项的信息包括有： 12345distance: 49.90470face: THREE.Face3faceIndex: 4object: THREE.Meshpoint: THREE.Vector3 点击物体后改变其透明度： See the Pen mouse-select by Jc (@JChehe) on CodePen. 最后最后，乱七八糟地整理了自己最近学 Three.js 的相关知识，其中难免出现一些自己理解不透彻，甚至是错误的观点，希望大家能积极提出来。当然，笔者也会捉紧学习，不断完善文章。希望大家多多关注 凹凸实验室。感谢~👏 参考资料 Three.js 开发指南 WebGL Fundamentals dragon/threejs教程","pubDate":"Mon, 28 Aug 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/08/28/getting-started-with-threejs/","category":"Web开发"},{"title":"AT - 前端 UI 组件库","link":"https://aotu.io/notes/2017/08/28/at-ui/","description":"AT-UI 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 没错，这是又一款基于 Vue 的前端 UI 组件库，又双叒叕款 UI 库~又双叒叕款轮子~ 但在人从众多类似的轮子中，AT-UI 属于视觉风格比较清新的一款。同时 AT-UI 是凹凸实验室官方出品，带有凹凸品牌风格的一套 UI KIT，旨在解决网站项目开发前期的「UI 库选择恐惧症」。 官网：https://at.aotu.io/项目地址：https://github.com/at-ui/at-ui 特性 基于 Vue 开发组件 基于 npm + webpack + babel 的工作流，支持 ES2015 CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风格（详见：AT-UI-Style） 项目背景目前市面上同类型的开源项目已经不少了，Antd, iView, Element 等精品项目也是圈粉大拿，成为许多 Web 开发者做管理端的首选 UI 库。为什么在竞争如此激烈的背景下，我们还要做同类型产品 AT-UI 呢？ 首先作为一个成熟的前端团队，我们需要一套统一的 UI 库，以便于更好的对项目进行维护迭代。其次团队成员在日常开发中，会输出一些自定义的组件（例如甘特图等），如果能快速整合到 UI 库中，便可以快速进行测试迭代。最后，我们既有基于 Vue 的项目，也有基于 React 的项目，为了保证不同框架的项目能共用一套 UI，我们迫切需要一款样式能独立迭代的 UI 库。于是乎，秉承着造轮子，也要造好轮子的心态，开始了 AT-UI 的构建之旅。 愿景我们希望 AT-UI 是一款视觉层面精美，代码层面高质量的 UI 库。同时也希望 AT-UI 能包含尽可能多的组件，能做到不请「外援」。为此，我们会尽可能完善各类型的组件，也非常欢迎组件 PR。 AT-UI 的部分组件借鉴了优秀项目 Antd, Element 和 iView 的实现思路及相关源码，并非闭门造车 安装使用 npm 安装推荐使用 npm 的方式进行开发，享受 node 生态圈和 webpack 工具链带来的便利。通过 npm 安装的模块包，我们可以轻松的使用 import 或者 require 的方式引用 123npm install at-uinpm install at-ui-style 浏览器标签引入可以采用传统的 &lt;script&gt; 和 &lt;link&gt; 标签的方式引入资源，并且全局使用 AT-UI。可以在 UNPKG 上找到最新版本的资源文件，然后在页面中直接引入。 123456&lt;!-- 引入Vue --&gt;&lt;script src=\"//vuejs.org/js/vue.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入样式 --&gt;&lt;link rel=\"stylesheet\" href=\"//unpkg.com/at-ui-style/css/at.min.css\"&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=\"//unpkg.com/at-ui/dist/at.min.js\"&gt;&lt;/script&gt; Demo 示例 更多使用说明，请阅读文档 AT-UI 写在最后秉承万维网的开放精神，以及开源世界的信条，我们接受各种评价和讨论，最终目标是为开源世界贡献我们的一份力，感恩！欢迎各位同学使用 AT-UI，如果你在使用过程中遇到问题，或者有好的建议，欢迎给我们提 Issue 或者 Pull Request","pubDate":"Mon, 28 Aug 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/08/28/at-ui/","category":"Web开发"},{"title":"CSS技巧：逐帧动画抖动解决方案","link":"https://aotu.io/notes/2017/08/14/fix-sprite-anim/","description":"笔者所在的前端团队主要从事移动端的H5页面开发，而团队使用的适配方案是: viewport units + rem。具体可以参见凹凸实验室的文章 – 利用视口单位实现适配布局 。 笔者目前（2017.08.12）接触到的移动端适配方案中，「利用视口单位实现适配布局」是最好的方案。不过使用 rem 作为单位会遇到以下两个难点： 微观尺寸（20px左右）定位不准 逐帧动画容易有抖动 第一个难点的通常出现在 icon 绘制过程，可以使用图片或者 svg-icon 解决这个问题，笔者强烈建议使用 svg-icon，具体理由可以参见：「拥抱Web设计新趋势：SVG Sprites实践应用」。 第二个难点笔者举个例子来分析抖动的原因和寻找解决方案。 一个抖动的例子做一个8帧的逐帧动画，每帧的尺寸为：360x540。 1234567891011121314151617.steps_anim &#123; position: absolute; width: 9rem; height: 13.5rem; background: url(//misc.aotu.io/leeenx/sprite/m.png) 0 0 no-repeat; background-size: 45rem 13.5rem; top: 50%; left: 50%; margin: -5.625rem 0 0 -5.625rem; animation: step 1.2s steps(5) infinite; &#125;@keyframes step &#123; 100% &#123; background-position: -45rem; &#125;&#125; 观察在主流（手机）分辨率下的播放情况： iPhone 6(375x667)iPhone 6+(414x736)iPhone 5(320x568)Android(360x640) iPhone 6 (375x667) iPhone 6+ (414x736)iPhone 5 (320x568)Android (360x640) ~function() { var _resize = function() { var w = document.body.clientWidth; if(w < 540) { J_table1.style.display = \"none\"; J_table2.style.display = \"block\"; } else { J_table1.style.display = \"block\"; J_table2.style.display = \"none\"; } } _resize(); window.addEventListener(\"resize\", _resize); }(); 四种分辨率下，可以看到除了 ip6 其它的三种分辨率都发生了抖动。（ip6 不抖动的原因是适配方案是基本于 ip6 的分辨率订制的。） 分析抖动图像由终端（屏幕）显示，而终端则是一个个光点（物理像素）组成的矩阵，换句话说图片也一组光点矩阵。为了方便描述，笔者假设终端上的一个光点代表css中的1px。 以下是一张 9px * 3px 的sprite: 每帧的尺寸为 3px * 3px，逐帧的取位过程如下： 把 sprite 的 background-size 的宽度取一半，那么终端会怎么处理？9 / 2 = 4.5终端的光点都是以自然数的形式出现的，这里需要做取整处理。取整一般是三种方式：round/ceil/floor。假设是 round ，那么 background-size: 5px，sprite 会是以下三种的一个： 情况一 情况二 情况三 理论上，5 / 3 = 1.666...。但实际上光点取整后，三个帧的宽度都不可能等于 1.666...，而是有一个帧的宽度降级为 1px（亏），另外两个宽度升级为 2px（盈），笔者把这个现象称作「盈亏互补」。 再看一下盈亏互补后，逐帧的取位过程： 情况一 情况二 情况三 可以看到由于盈亏互补导致了三个帧的宽度不一致，亏的那一帧在动画中的表示就是抖动。 笔者总结抖动的原因是：sprite在尺寸缩放后，帧与帧之间的盈亏互补现象导致动画抖动 附注：1px 由几个光点表示是由以终端的 dpr 决定 解决方案「盈亏互补」也可以说是「盈亏不一致」，如果尺寸在缩放后「盈亏一致」那么抖动现象可以解决。 解决构想一笔者根据「盈亏一致」设计了「解决构想一」： 根据上图，其实很容易就联想到一个简单的方案：不用雪碧图（即一帧对应一张图片）。这个方案确实是可以解决抖问题，不过笔者并不推荐使用它，因为它有两个负面的东西： KB变大与请求数增多 多余的 animation 代码 这个方案很简单，这里就不赘述了。 解决构想二把逐帧取位与图像缩放拆分成两个独立的过程，就是笔者的「解决构想二」： 实现「构想二」，笔者首先想到的是使用 transform: scale()，于是整理了一个实现方案A： 12345678910111213141516171819202122232425262728293031323334.steps_anim &#123; position: absolute; width: 360px; height: 540px; background: url(//misc.aotu.io/leeenx/sprite/m.png) 0 0 no-repeat; background-size: 1800px 540px; top: 50%; left: 50%; transform-origin: left top; margin: -5.625rem 0 0 -5.625rem; transform: scale(.5); animation: step 1.2s steps(5) infinite;&#125;@keyframes step &#123; 100% &#123; background-position: -1800px; &#125;&#125;/* 写断点 */@media screen and (width: 320px) &#123; .steps_anim &#123; transform: scale(0.4266666667); &#125;&#125;@media screen and (width: 360px) &#123; .steps_anim &#123; transform: scale(0.48); &#125;&#125;@media screen and (width: 414px) &#123; .steps_anim &#123; transform: scale(0.552); &#125;&#125; 这个实现方案A存在明显的缺陷：scale 的值需要写很多断点代码。于是笔者结全一段 js 代码来改善这个实现方案B： css:1234567891011121314151617.steps_anim &#123; position: absolute; width: 360px; height: 540px; background: url(\"//misc.aotu.io/leeenx/sprite/m.png\") 0 0 no-repeat; background-size: 1800 540px; top: 50%; left: 50%; transform-origin: left top; margin: -5.625rem 0 0 -5.625rem; animation: step 1.2s steps(5) infinite;&#125;@keyframes step &#123; 100% &#123; background-position: -1800px; &#125;&#125; javascript:123456789// 以下代码放到 &lt;head&gt;&lt;/head&gt; 中&lt;script&gt;document.write(\"&lt;style id='scaleStyleSheet'&gt;.steps_anim &#123;scale(.5); &#125;&lt;/style&gt;\"); function doResize() &#123; scaleStyleSheet.innerHTML = \".steps_anim &#123;-webkit-transform: scale(\" + (document.documentElement.clientWidth / 750) + \")&#125;\"; &#125;window.onresize = doResize; doResize(); &lt;/script&gt; 通过改善后的方案 CSS 的断点没了，感觉是不错了，不过笔者觉得这个方案不是个纯粹的构建方案。 我们知道 &lt;img&gt; 是可以根据指定的尺寸自适应缩放尺寸的，如果逐帧动画也能与 &lt;img&gt; 自适应缩放，那就可以从纯构建角度实现「构想二」。 SVG刚好可以解决难题！！！SVG 的表现与 &lt;img&gt; 类似同时可以做动画。以下是笔者的实现方案C。 html:123&lt;svg viewBox=\"0, 0, 360, 540\" class=\"steps_anim\"&gt; &lt;image xlink:href=\"//misc.aotu.io/leeenx/sprite/m.png\" width=\"1800\" height=\"540\" /&gt;&lt;/svg&gt; css:1234567891011121314151617.steps_anim &#123; position: absolute; width: 9rem; height: 13.5rem; top: 50%; left: 50%; margin: -5.625rem 0 0 -5.625rem; image &#123; animation: step 1.2s steps(5) infinite; &#125;&#125;@keyframes step &#123; 100% &#123; transform: translate3d(-1800px, 0, 0); &#125;&#125; 方案C的改良实现方案C很好地解决了方案A和方案B的缺陷，不过方案C也有它的问题：不利于自动化工具去处理图片。 自动化工具一般是怎么处理图片的？自动化工具一般是扫描 CSS 文件找出所有的 url(...) 语句，然后再处理这些语句指向的图片文件。 如果 &lt;image&gt; 可以改用 CSS 的 background-image 就可以解决这个问题，不过 SVG 不支持 CSS 的 background-image。但是，SVG有一个扩展标签：foreignObject，它允许向 &lt;svg&gt;&lt;/svg&gt; 插入 html 代码。在使用它前，先看一下它的兼容情况： iOS 与 Android 4.3 一片草绿兼容情况算是良好，笔者实机测试腾讯 X5 内核的浏览器兼容仍旧良好。以下是改良后的方案。 html:12345&lt;svg viewBox=\"0, 0, 360, 540\" class=\"steps_anim\"&gt; &lt;foreignObject class=\"html\" width=\"360\" height=\"540\"&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;/foreignObject&gt;&lt;/svg&gt; css:12345678910111213141516171819202122232425.steps_anim &#123; position: absolute; width: 9rem; height: 13.5rem; top: 50%; left: 50%; margin: -5.625rem 0 0 -5.625rem; &#125;.html &#123; width: 360px; height: 540px; &#125;.img &#123; width: 1800px; height: 540px; background: url(//misc.aotu.io/leeenx/sprite/m.png) 0 0 no-repeat; background-size: 1800px 540px; animation: step 1.2s steps(5) infinite; &#125;@keyframes step &#123; 100% &#123; background-position: -1800px 0; &#125;&#125; 改良后的方案DEMO: http://jdc.jd.com/fd/promote/leeenx/201708/svg-sprite.html 结语感谢阅读完本文章的读者。本文是笔者的个人观点，希望能帮助到有相关问题的朋友，如果本文有不妥之处请不吝赐教。 参考资料：https://stackoverflow.com/questions/9946604/insert-html-code-inside-svg-text-elementhttps://www.w3.org/TR/SVG/extend.htmlhttps://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject","pubDate":"Mon, 14 Aug 2017 13:09:53 GMT","guid":"https://aotu.io/notes/2017/08/14/fix-sprite-anim/","category":"Web开发"},{"title":"这里有你对 Web 游戏的疑问吗？","link":"https://aotu.io/notes/2017/07/23/some-doubts-about-web-games/","description":"本文记录了笔者对 Web 游戏的一些疑问，也许你也恰巧曾经遇到过。 回顾 Flash习大大说道：“不忘历史才能开辟未来，善于继承才能善于创新”。对于新生一代（如 00 后和我🙄 ），由于 Web 新标准的快速推进，有些旧事物也许未接触就已经被新事物取代了。如曾经如日中天的 Flash，现在被 HTML5 逐渐蚕食。 由于我未曾学习过 Flash 编程，所以通过查阅资料发现了一个网站——Waste Creative 公司的《Flash vs HTML5》，它对 Flash 与 HTML5 作出了比较（具体数据也许已过时，但整体趋势不变）。 Flash HTML5 Canvas 运行平台 桌面端 桌面端、移动端 桌面端浏览器支持率 99% 82% 3D 硬件加速支持率 Flash Player 11（stage3D）81% WebGL 53% 文件&amp;资源目录 可编译的 SWFs 意味着 Flash 可作为单个文件共享和重新托管（re-hosted）。这对于 Flash 游戏非常重要。 HTML5 的本质意味着它的基础资源会作为独立的文件加载。因此，HTML5 的托管需要更谨慎。 可视化创作 Flash IDE 对于设计师和新开发者来说是非常友好的，它拥有一个庞大的用户群体和社区。 相较于前者，HTML5 创作工具（Animate CC）目前还处于起步阶段，没有明确的“工业标准”。 移动端浏览器 目前的浏览器不再有 Flash 插件，Adobe 已经停止对先前移动端 player 的支持与迭代。 Canvas 几乎已得到所有浏览器的支持，而 WebGL 的支持程度也逐渐提高。 在移动端早就不支持 Flash 的情况下，现在越来越多桌面端现代浏览器默认不启动 Flash 了。在可预见的未来，HTML5 （Canvas 2D 与 WebGL）的支持度会越来越高。 尽管 HTML5 的支持度越来越高，但是对于很多未接触 Flash 开发而直接着手于 HTML5 开发的新人来说，前辈们的经验无疑是非常宝贵的。在 2014 年有将近 30 万的 Flash 开发者，其中 90% 是和游戏相关的，他们对 Web 游戏的开发和理解都胜于任何使用其他 Web 前端技术进行开发游戏的群体。 基于这点，很多 HTML5 游戏引擎在 API 设计等方面都会考虑 Flash 这个开发群体。另外 Adobe Animate CC（前身是 Flash Professinal）在支持 Flash SWF 文件的基础上，加入了对 HTML5 的支持。因此，熟悉 Flash 的设计师/开发者就能通过 Animate CC 进行可视化创作，然后导出基于 Canvas 的游戏/动画。 渲染模式：Canvas 2D 与 WebGL我们常常听到有人说：“3D 场景用 WebGL”。 这句话对于未深入学习相关知识的人来说，会潜移默化地在脑中留下这样的刻板印象：“WebGL 就是 3D，3D 就是 WebGL”。 其实不然，因为我们也能在三维空间里绘制二维物体嘛。因此，我们能看到很多 2D 游戏引擎（如 PixiJS，Egret）会提供两种渲染模式：Canvas 2D 和 WebGL。但由于两者 API 不相同，游戏引擎会对两者进行一定抽象封装，为开发者提供一致的 API。 注：PixiJS 的定位是渲染器。而为了方便描述，在本文中我们暂且称它为游戏引擎。 另外，我们可以看到在支持上述两种渲染模式的游戏引擎中，都会优先启用 WebGL，若不兼容则回退至 Canvas 2D。游戏引擎之所以采取这种策略，目的之一是获取更高的性能。 那为什么 WebGL 的性能比 Canvas 2D 高？ 在回答上述问题前，我们先了解 Canvas 2D 与 WebGL 的基本信息。 我们都知道 &lt;canvas&gt; 元素提供一个了空白区域，让特定的 JavaScript API 进行绘制。其中，绘制 API 取决于用户所指定的绘制上下文，如 Canvas 2D 或 WebGL。 Canvas 2D对于 Chrome，其 Canvas 2D 的底层实现是 Skia 图形库。其实不止于 Chrome，该库还服务于 Chrome OS、 Android、Mozilla Firefox 和 Firefox OS 等众多产品。 通过在 Chrome 地址栏输入 about:gpu 可看到，Canvas 2D 是支持硬件加速的。若未启用，则在地址栏输入 about:flags，然后启用 Accelerated 2D canvas 选项并重启浏览器即可。 1234567891011121314Graphics Feature StatusCanvas: Hardware accelerated ***Flash: Hardware acceleratedFlash Stage3D: Hardware acceleratedFlash Stage3D Baseline profile: Hardware acceleratedCompositing: Hardware acceleratedMultiple Raster Threads: EnabledNative GpuMemoryBuffers: Hardware acceleratedRasterization: Hardware acceleratedVideo Decode: Hardware acceleratedVideo Encode: Hardware acceleratedWebGL: Hardware acceleratedWebGL2: Hardware accelerated WebGL什么是 WebGL（Web Graphics Library）？简而言之，它允许 JavaScript 对图形硬件进行低阶编程。这无疑让 Web 页面能更好地利用显卡的优势，如 3D、着色器和卓越性能。 另外，目前 WebGL 有两个版本，其中 WebGL 1.0 是基于 OpenGL ES 2.0，WebGL 2.0 是基于 OpenGL ES 3.0。 GPU 是如何渲染 2D 图像的？在了解了 Canvas 2D 和 WebGL 的基本信息后，我们再看看 GPU 是如何渲染 2D 图像的。 首先，我们先介绍渲染处理，以便你了解测试中发生了什么。尽管有点简化，但它能让你有一个基本的认识。要在低阶渲染器（如 WebGL 和 DirectX）中绘制 2D 图像，首先需要一个能包围该图像的四边形。因此，我们需要提供该四边形每个角的坐标（x, y）。这里的每个角都被称为顶点（vertex），如下图的红点所示： 包围着图像的四边形 为了高效地绘制大量的 2D 图像，我们需要有一个能装载每个图像所有顶点的列表。该列表存储在顶点缓冲区，显卡会进行读取绘制。下图中有 5 个海盗公主，有的旋转，有的缩放，共有 20 个顶点。 多个图像时的顶点 显卡是非常先进的技术，它已被庞大的 3D 游戏行业推动多年。现在它的运算速度非常快，渲染 2D 图像的速度更是快得难以形容。因为它的渲染速度甚至比你告诉它渲染哪张图更快。换句话说，计算每个顶点的位置并将其发送到显卡的这个过程可能需要 2 微秒，但显卡完成其工作只需 1 微秒，然后空闲地等待下一个指令。 由此可看出，2D 游戏的性能主要受限于顶点缓冲区的填充速度。所以这里的问题是：计算顶点的位置和将其填充到缓冲区的速度能有多快？ 下面我们将分别对 Canvas 2D 和 WebGL 进行测试。 性能测试为了测试两个渲染器的性能，我们编写了一个标准测试。首先，我们有一个蓝色正方形图像，然后在其基础上绘制足够多的图像，直至让帧率降至 30FPS。这样做是为了最大限度地减少每帧中不必要的计算量，确保我们能得出顶点的填充速度。另外，图像是具有透明度的，因此我们能看到它们不断地堆叠起来，如下图： 测试示例图 我们可在各个浏览器上进行测试，以查看它们的实际渲染速度： Canvas 2D 性能测试链接&gt;&gt; WebGL 性能测试链接&gt;&gt;（前提是要支持/开启 WebGL，否则会回退至 Canvas 2D） 在 Early 2013 MacBook Pro（系统为 macOS 10.12.5，硬件配置为 i7 2.4GHz 处理器、8G 1600 MHz DDR3 内存、GT 650M 显卡）上测试可得出以下数据： 注：对于 Windows，可能还需要修改独显对测试浏览器的支持（默认可能是集显）。 Chrome 59.0.3071.115（正式版本）（64 位）测试数据如下： Chrome Canvas 2D——分数为 2415 Chrome WebGL——分数为 13711 Safari 10.1.1（12603.2.4）测试数据如下： Safari Canvas 2D——分数 7481 Safari WebGL——分数 52061 Firfox 54.0.1（64位） 测试数据如下： Firfox Canvas 2D——分数 5992 Firfox WebGL——分数 66291 由上述数据可得：3 款浏览器的 WebGL 性能都优于 Canvas 2D，Chrome 是 5.6 倍、Safari 是 6.95 倍、Firfox 是 11 倍。而且由分数可看出：Safari 和 Firfox 无论是 Canvas 2D 还是 WebGL 都远强于 Chrome。 为何 WebGL 普遍比 Canvas 2D 性能要高呢？ 对于 Canvas 2D，其 API 相对于 WebGL 更高阶。即它实际并没有直接发送顶点信息到顶点缓冲区，而只是描述了在某个位置上绘制一个 2D 图像，然后再让浏览器计算出具体的顶点信息。 对于 WebGL，它直接给出所有对象的顶点信息。这意味着无需再进行任何计算来确定顶点的信息。这样就可以消除浏览器对顶点处理的开销，从而直接复制到顶点缓冲区。另外，从上面我们的实际测试结果可知，WebGL 的性能提升效果是非常明显的。当然，上述只是简单的测试，实际应用中还是需要考虑实际情况。 综上所述，影响两者性能的因素有很多，如操作系统、硬件、浏览器的底层实现与优化和项目代码质量等。在实际测试中，现代浏览器的 WebGL 性能在整体上优于 Canvas 2D。 也许有人认为：性能够用就好，再高也就是过剩。其实不然，因为除了保证画面流畅外，性能高还有以下好处： 运行流畅且稳定（不会因其他因素干扰而掉帧）。 游戏开发商能拥有更多空间去增加更多功能和提高画面质量。 运行效率更高，能耗更低（电池使用量、发热量）。 游戏为什么要 60FPS，而电影 24FPS 就行一般来说，要达到流畅的体验，电影需要 24FPS，而游戏却要 60FPS。 概括来说，造成两者差异的主要原因有： 两者图像生成原理不同 电影的 FPS 是稳定的，而游戏则是不稳定 更详细的解答请看以下两个链接（此刻，我不生产内容，只是内容的搬运工）： 为什么游戏帧数一般要到 60 帧每秒才流畅，而过去的大部分电影帧数只有 24 帧每秒却没有不流畅感？ 為什麼電影 24 格就行，但遊戲卻要 60 格？ 最后其实原来文章的大纲不止于以上几点（还有 TypeScript、WebAssembly、脏矩形、骨骼动画等），但由于笔者深知自己能力和经验上的不足，所以把模棱两可或不确定的点都取消了。但笔者会在后续的学习中不断完善，甚至增加新的知识点。所以这是一篇不定时更新的博文，请持续关注 凹凸实验室。 看了以上几个心中疑问后，是否觉得离『游戏入门』的门近了一点呢？ 最后，希望大家能在评论区提出更多关于 Web 游戏的疑问，说不定可以收录至本文哦👏。 参考资料： HTML5 游戏引擎深度评测 如何看待 HTML5 开源游戏引擎 Egret，HTML5 游戏开发的前景如何？ HTML5 2D gaming performance analysis","pubDate":"Sun, 23 Jul 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/07/23/some-doubts-about-web-games/","category":"Web开发"},{"title":"一篇文章带你快速入门 CreateJS","link":"https://aotu.io/notes/2017/07/19/createjs/","description":"CreateJS 简介 官网：http://www.createjs.cc/ CreateJS 中包含以下四个部分： EaselJS：用于 Sprites 、动画、向量和位图的绘制 TweenJS：用于做动画效果 SoundJS：音频播放引擎 PreloadJS：网站资源预加载 这四个部分都可以单独的引用，可选可不选。 一. 预加载 PreloadJS CreateJS 的 PreloadJS 非常的实用，实现起来也比较简短，如下： 1234567891011//放置静态资源的数组var manifest = [ &#123;src: './images/car_prop2_tyre@2x.png', id: 'tyre'&#125;];var queue = new createjs.LoadQueue();queue.on('complete', handleComplete, this);queue.loadManifest(manifest);//资源加载成功后,进行处理function handleComplete() &#123; var tyre = queue.getResult('tyre'); //获取加载资源&#125; Image 跨域小坑： 有些时候跨域的图片可以成功地使用 Canvas 渲染出来，但是到需要对图片进行某些处理的时候，浏览器就会报错。 “被污染的” Canvas ? 尽管没有 CORS 授权也可以在 Canvas 中使用图像, 但这样做就会污染画布。 只要 Canvas 被污染, 就不能再从画布中提取数据, 也就是说不能再调用 toDataURL() 和 getImageData() 等方法, 否则会抛出安全错误 (security error) 。 解决图片跨域有2种解决方法： 图片所在的服务器设置 Access-Control-Allow-Origin “*” 响应头 手动将 IMG 的 url 转换成当前域名的 url ，详细处理方法 在服务器不支持图片跨域的情况下，我们自己手动将图片转换成同域是比较麻烦的，因此，使用 CreateJS 的 PreloadJS ,将最后一个参数设置为 Anonymous 即可。 12345var queue = new createjs.LoadQueue(false,'','Anonymous'); //LoadQueue ( [preferXHR=true] [basePath=\"\"] [crossOrigin=\"\"] )第一个参数为true，代表通过xhr形式加载.basePath 在加载资源时的，会把basePath加载url前面。这样加载同一个目录下的文件时，可以方便一点。 但是如果url是以协议（如”http://”）或者”../”这样路径开头时，不会添加basePath。crossOrigin 设置为Anonymous的时候，则表示允许跨域 二. EaselJS 的常用 API 画图片用 (Bitmap) 画图形，比如矩形，圆形等用 (Shape) 【类似于改变坐标x，y，增加阴影 Shadow ，透明度 Alpha ，缩小放大 ScaleX/ScaleY 都可以做到】 画文字，用 (Text) 还有容器 Container 的概念，容器可以包含多个显示对象 三. EaselJS 绘图的大致流程 大致流程：创建显示对象→设置一些参数→调用方法绘制→添加到舞台→ update() ，代码如下：1234567891011var canvas = document.querySelector('#canvas');//创建舞台var stage = new createjs.Stage(canvas);//创建一个Shape对象，此处也可以创建文字Text,创建图片Bitmapvar rect = new createjs.Shape();//用画笔设置颜色，调用方法画矩形，矩形参数：x,y,w,hrect.graphics.beginFill(\"#f00\").drawRect(0, 0, 100, 100);//添加到舞台stage.addChild(rect);//刷新舞台stage.update(); graphics 可以设置一些样式，线条宽度，颜色等等，也可以调用一些方法绘制图形，比如矩形 drawRect ，圆形 drawCircle 等等，具体可以自己查看 API。注意：以上的步骤每一步都要有，否则页面不会有绘制的物体。 四. Tick 事件对于有频繁发生改变的物体，如果在每一处变化都刷新舞台的话，代码会比较冗余，因此我们可以写一个 Tick 事件，在每一次 Tick 的时候 update 舞台。123456789createjs.Ticker.addEventListener(“tick”, tick);function tick(e) &#123; if (e.paused !== 1) &#123; //处理 stage.update(); //刷新舞台 &#125;else &#123;&#125;&#125;createjs.Ticker.paused = 1; //在函数任何地方调用这个，则会暂停tick里面的处理createjs.Ticker.paused = 0; //恢复游戏 在暂停的时候，页面仍会触发 Tick 事件，如果需要完全移除 Tick 事件，则使用 1createjs.Ticker.removeEventListener(\"tick\", tick); 五. Ticker 帧频率上面说的 Tick 事件，每一次触发的频率是可以修改的。理想的帧频率是 60FPS。1createjs.Ticker.setFPS(60); 六. CreateJS 的渲染模式CreateJs 提供了两种渲染模式，一种是用 setTimeout ，一种是用 requestAnimationFrame ，默认是 setTimeout ，默认的帧数是 20 ，一般的话还没有什么区别，但是如果动画多的话，设置成 requestAnimationFrame 模式的话，就会感觉到动画如丝般的流畅。1createjs.Ticker.timingMode = createjs.Ticker.RAF; 使用这种模式，则会忽略 Ticker 的帧频 FPS 。 七. CreateJS 事件EaselJS 事件默认是不支持 Touch 设备的，需要以下代码才支持：1createjs.Touch.enable(stage); 对于 Bitmap， Shape 等对象，都可以直接使用 addEventListener 进行事件监听。12bitmap = new createjs.Bitmap('');bitmap.addEventListener（‘click’，handle）; 八. 优化对所绘制物体的控制能力 控制多个显示对象的层级关系 Stage ， Container 对象有个 Children 属性代表子元素，是一个数组，里面的元素层级像下标一样从 0 开始，简单来说就是后面的覆盖前面的（类似于z-index）,后 addChild 的对象则在数组的后面。我们也可以动态改变 Children 的层叠效果。1obj.parent.setChildIndex(obj, n); //n为设置的层级 利用容器 Container 它可以包含 Text 、 Bitmap 、 Shape 、 Sprite 等其他的 EaselJS 元素，包含在一个 Container 中方便统一管理。比如一辆汽车由汽车本身，气泡提示，加速效果，减速效果组成，我们可以将这几个部分放在同一个 Container 中，统一移动。使用方法也比较简单：1234var contain = new createjs.Container();contain.addChild(bgImg);contain.addChild(bitmap);stage.addChild(contain); 我们在后期会频繁对这个 Container 里面的元素进行操作，比如展示加速效果，取消展示减速效果。那我们可以给这些元素设置name属性，之后可以直接使用 getChildByName 获取到该对象。123bitmap.name = ‘quick’; //设置name值quick = this.stage.getChildByName(“quick”); //使用name值方便获取到该对象quick.visible = true; //显示该效果 九. 绘制图像并对图像进行操作 绘制图片123var bg = new createjs.Bitmap(\"./background.png\");stage.addChild(bg);stage.update(); 按照上面的 EaselJS 的正常的绘制流程来说，上面这段代码应该可以正常显示。但是，只是有些情况下可以正常显示的，这个图像资源需要确定加载成功后才可以 new ，否则不会有图像在画布上，如果有做资源预加载，可以直接使用上面的代码，如果没有，则需要在 Image 加载完成 Onload 之后才进行绘制。1234567var img = new Image();img.src = './img/linkgame_pass@2x.png';img.onload = function () &#123; var bg = new createjs.Bitmap(\"./background.png\"); stage.addChild(bg); stage.update();&#125; 仅仅绘制图片是不够的， CreateJS 提供了几种处理图片的方法： 给图片增加遮罩层使用 mask 属性，可以只显示图片和 shape 相交的区域12345678910111213stage = new createjs.Stage(\"gameView\");bg = new createjs.Bitmap(\"./img/linkgame_pass@2x.png\");bg.x = 10;bg.y = 10;//遮罩图形shape = new createjs.Shape();shape.graphics.beginFill(\"#000\").drawCircle(0, 0, 100);shape.x = 200;shape.y = 100;bg.mask = shape; //给图片bg添加遮罩stage.addChild(shape);stage.addChild(bg);stage.update(); 常用应用场景：用来剪裁图片，比如显示圆形的图片等 给图片增加滤镜效果12var blur = new createjs.BlurFilter(5,5,1);bg.filters = [blur]; 我们发现，图片还是没有变模糊，原因是图片添加了 Filter 后 Stage 立即刷新， Filter 只能保持一帧的效果，第二帧 Filter 则失效了。而使用图片的 cache() 方法后，可以使得无论舞台怎么刷新，都可以保持住 Filter 的效果，添加 cache 还有很多作用，可以提高 FPS ，缓存等1bg.cache(0,0,bg.image.width,bg.image.height); 使用 Rectangle 剪裁图片使用 EaselJS 内置的 Rectangle 对象来创建一个选取框，显示图片的某各部分。12345678stage = new createjs.Stage(\"gameView\");bg = new createjs.Bitmap(\"./img/linkgame_pass@2x.png\");bg.x = 10;bg.y = 10;var rect = new createjs.Rectangle(0, 0, 121, 171);bg.sourceRect = rect;stage.addChild(bg);stage.update(e); 适用场景：拼图小游戏，剪裁图片…… 具体的使用方法我们都知道啦，接下来用一个小 Demo 练练手 – 实现一个无缝连接的背景图，模拟汽车加速的状态 1234567891011121314151617181920212223242526272829this.backdrop = new createjs.Bitmap(bg);this.backdrop.x = 0;this.backdrop.y = 0;this.stage.addChild(that.backdrop);this.w = bg.width;this.h = bg.height;//创建一个背景副本，无缝连接var copyy = -bg.height;this.copy = new createjs.Bitmap(bg);this.copy.x = 0;this.copy.y = copyy; //在画布上 y 轴的坐标为负的背景图长//使用 CreateJS 的 Tick 函数，逐帧刷新舞台createjs.Ticker.addEventListener(\"tick\", tick);function tick(e) &#123; if (e.paused !== 1) &#123; //舞台逐帧逻辑处理函数 that.backdrop.y = that.speed + that.backdrop.y; that.copy.y = that.speed + that.copy.y; if (that.copy.y &gt; -40) &#123; that.backdrop.y = that.copy.y + copyy; &#125; if (that.copy.y &gt; -copyy - 100) &#123; that.copy.y = copyy + that.backdrop.y; &#125; &#125; that.stage.update(e);&#125; demo体验链接： http://jdc.jd.com/fd/h5/peidan/demo/car.html 总结整篇文章介绍了下面几个部分 详细介绍了 CreateJS 的常用 API CreateJS 的一些常见 bug 及解决方法 CreateJS 实现小 Demo 参考： https://github.com/pfan123/code-snippet/issues/10 如何使用 CreateJS 来编写HTML5游戏（一）EaselJS简介 如何使用 CreateJS 来编写HTML5游戏（二）使用EaselJS处理图片 如何使用 CreateJS 来编写HTML5游戏（三）使用EaselJS中的制作Sprite类制作 如何使用 CreateJS 来编写HTML5游戏（四）TweenJS和Tick动画 如何使用 CreateJS 来编写HTML5游戏（五）PreloadJS和SoundJS 如何使用 CreateJS 来编写HTML5游戏（六）完成一个简单的打飞机游戏（上） 如何使用 CreateJS 来编写HTML5游戏（七）完成一个简单的打飞机游戏（下）","pubDate":"Wed, 19 Jul 2017 08:25:35 GMT","guid":"https://aotu.io/notes/2017/07/19/createjs/","category":"移动开发"},{"title":"Vue 探索与实践","link":"https://aotu.io/notes/2017/07/17/The-Exploration-and-Practice-of-Vue/","description":"本文主要讲了实际业务在结合 vue 开发的过程中的探索与实践。","pubDate":"Mon, 17 Jul 2017 07:04:31 GMT","guid":"https://aotu.io/notes/2017/07/17/The-Exploration-and-Practice-of-Vue/","category":"项目总结"},{"title":"实现一个 Swiper","link":"https://aotu.io/notes/2017/07/17/design-a-swiper/","description":"设计一个五图的 Swiper，设计稿如下： Swiper 的功能如下： 左右切换 无限轮播 任意图片数 接下来，详细介绍这三个功能的实现过程： 左右切换这里指触发左右切换的手指交互，目前主要是以下两种： 方案 示意图 手指拖拽 手势判断 手指拖拽容易有性能问题并且实现相对麻烦，所以笔者果断采用了手势判断，伪代码如下： 123456789101112131415swiper.on(\"touchstart\", startHandle); swiper.on(\"touchmove\", moveHandle); function startHandle(e) &#123; var x0 = e.touch.pageX, y0 = e.touch.pageY; &#125;function moveHandle(e) &#123; var x = e.touch.pageX, y = e.touch.pageY, offsetX = x0 - x, offsetY = y0 - y; if(offsetX &lt;= -50) &#123; // 向右 // to do &#125; else if(offsetX &gt;= 50) &#123; // 向左 // to do &#125; &#125; 无限轮播无限轮播要面对的是两个问题： 轮播的数据结构； 前端渲染 数据结构无限轮播笔者联想到旋转木马。 在数据结构中有一个叫循环链表的结构，可以完美地模拟旋转木马。 javascript 没有指针，链表需要由数组来模拟。分析循环链表的两个重点特征： 数据项都由头指针访问 链表头尾有指针串联 笔者用 pop&amp;unshift/shift&amp;push APIs 模拟指针的前后移动，解决了链表头尾串联的问题，然后用数组的第一个元素（Arrayy[0]）作为头指针。 伪代码如下： 12345678if(left) &#123; queue.push(this.queue.shift()); swap(\"left\"); // 渲染&#125;else &#123; queue.unshift(this.queue.pop()); swap(\"right\"); // 渲染&#125; 前端渲染swiper 换个角度来看，它其实是一个金字塔： 梳理好层级问题再把过渡补间写上，swiper 的渲染就已经OK了。以下是伪代码： 123456789101112131415function swap() &#123; // queue 循环链表 // nodelist 图片列表 for(var i=0; i&lt;5; ++i) &#123; nodelist[queue[i]].style.cssText = css[i]; &#125;&#125;// 层级与补间css = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // pic2 \"z-index: 1; other css...\", // pic3 \"z-index: 1; other css...\", // pic4 \"z-index: 2; other css...\" // pic5]; 任意图片数图片数可以分成三种情况来讨论：count == 5; count &gt; 5; count &lt; 5。其中 count == 5 是理想条件，上几节就是围绕它展开的。本节将分析 count &gt; 5 与 count &lt; 5 的解决思路。 count &gt; 5将循环链表（5节）扩容： 扩容后的工作过程如下： 循环链表指针移动； 渲染节点（1, 2, 3, n-1, n）； 回收节点（4, 5, …, n-2）。 注：这里的回收节点指隐藏节点（display: none/visibility: hidden） 渲染金字塔如下： 为了提高性能笔者在循环链表与节点中间创建了一个快照数组 snapshot，snapshot 映射节点上的属性，循环链表每一次变动都会生成一个新的快照数组 nextSnap，通过 nextSnap 来更新 snapshot 与 节点样式。以下是实现的伪代码： 12345678910111213141516171819202122232425262728293031323334353637// 初始化function init() &#123; nodelist = document.querySelectorAll(\"li\"); // nodelist n = nodelist.length; queue = [0, 1, 2, ..., n]; // 循环链表 snapshot = new Array(n); // 映射 nodelist 的快照 // 初始化 nodelist 样式 for(var i=0; i&lt;n; ++i) &#123; nodelist[i].style.cssText = defaultCssText; &#125;&#125;// 缺省样式 var defaultCssText = \"visibility: hidden\"; // 层级与补间css = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // pic2 \"z-index: 1; other css...\", // pic3 \"z-index: 1; other css...\", // pic(n-1) \"z-index: 2; other css...\" // picn]; // 切换渲染 function swap() &#123; nextSnap = new Array(n); // swiper切换后的快照 for(var i in [0, 1, 2, n-1, n]) &#123; nextSnap[queue[i]] = css[i]; &#125; // 更新 snapshot 与 nodelist for(var i=0; i&lt;n; ++i) &#123; if(snapshot[i] != nextSnap[i]) &#123; // 快照更新 snapshort[i] = nextSnap[i]; // 样式更新 nodelist[i].style.cssText = snapshort[i] || defaultCssText); &#125; &#125;&#125; count &lt; 5当count &gt;= 5时，渲染节点是一个稳定的金字塔： 当 count &lt; 5时，渲染金字塔变得不确定： count 金字塔 1 2 3 4 由于只有 count == 1 ~ 4 四种情况，可以直接用个 swith 把状态列表出来： 1234567891011121314151617181920212223242526272829303132// 层级与补间css1 = [ \"z-index: 1; other css...\", // pic1]css2 = [ \"z-index: 2; other css...\", // pic1 \"z-index: 1; other css...\" // pic2] css3 = [ \"z-index: 2; other css...\", // pic1 \"z-index: 1; other css...\", // pic2 \"z-index: 1; other css...\" // pic3] css4 = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // pic2 \"z-index: 2; other css...\", // pic3 \"z-index: 1; other css...\" // pic4] switch(n) &#123; case 4: css = css4, renderList = [1, 4, 2, 3], break; case 3: css = css3, renderList = [1, 3, 2], break; case 2: css = css2, renderList = [1, 2], break; default: css = css1, renderList = [1], break; &#125;function swap() &#123; // queue 循环链表 // nodelist 图片列表 for(var i in renderList) &#123; nodelist[queue[renderList[i]]].style.cssText = css[i]; &#125;&#125; 上面的伪代码显得很冗长，并不是个好实现方式。不过仍能从上面代码获得启发: 渲染列表(renderList) 与循环链表(queue)的对应关系 —— [shift, pop, shift, pop, shift]。于是伪代码可以简化为： 12345678910111213141516171819function swap() &#123; // queue 循环链表 // renderList 渲染列表 while(queue.length &gt; 0 &amp;&amp; renderList.length &lt; 5) &#123; renderList.push(renderList.length % 2 ? queue.pop() : queue.shift()); &#125; // nodelist 图片列表 for(var i=0; i&lt;renderList.length; ++i) &#123; nodelist[queue[i]].style.cssText = css[i]; &#125;&#125; // 层级与补间css = [ \"z-index: 3; other css...\", // pic1 \"z-index: 2; other css...\", // picn \"z-index: 2; other css...\", // pic2 \"z-index: 1; other css...\", // pic(n-1) \"z-index: 1; other css...\" // pic3]; 细节优化笔者实现的 swiper: https://leeenx.github.io/mobile-swiper/v1.html (count &gt;= 5)运行效果如下： 仔细观察能看到切换效果上的小瑕疵： 造成这个瑕疵是因为同值 z-index 节点的渲染层级与 DOM 树的出现顺序相关： 后出现的节点层级更高。 解决方案很简单，为 swiper 添加一个 translateZ 。如下伪代码： 12345678910// 支持 3d 透视swiper.style[\"-webkit-transform-style\"] = \"preserve-3d\"; // 层级与补间css = [ \"z-index: 3; transfomr: translateZ(10px)\", // pic1 \"z-index: 2; transfomr: translateZ(6px)\", // picn \"z-index: 2; transfomr: translateZ(6px)\", // pic2 \"z-index: 1; transfomr: translateZ(2px)\", // pic(n-1) \"z-index: 1; transfomr: translateZ(2px)\" // pic3]; 添加 z-index 后的swiper: https://leeenx.github.io/mobile-swiper/v2.html 再看看 count &lt; 5 的运行效果： count 效果图 地址 1 https://leeenx.github.io/mobile-swiper/v2.html?count=1 2 https://leeenx.github.io/mobile-swiper/v2.html?count=2 3 https://leeenx.github.io/mobile-swiper/v2.html?count=3 4 https://leeenx.github.io/mobile-swiper/v2.html?count=4 当 count == 2 / count == 4 时，swiper 向右切换时怪怪的，总感觉有什么不对！！其实问题出在渲染金字塔上，偶数swiper 在视觉在不是一个对称的图形： 由于笔者使用定势渲染的原因造成金字塔底被固定在左侧，当向右侧切换时会觉得很奇怪。这里其实只要加一个方向修正即可，以下是修正的伪代码： 1234567891011121314function swap(orientation) &#123; odd = 1; // 奇偶标记 total = queue.length; // 渲染列表长度 last = total - 1; // renderList 最后一个索引 while(queue.length &gt; 0 &amp;&amp; renderList.length &lt; 5) &#123; renderList.push(odd ? queue.pop() : queue.shift()); odd = !odd; // 取反 &#125; // nodelist 图片列表 for(var i=0; i&lt;5; ++i) &#123; // 偶数并且向右切换，将最后一个节点右置 nodelist[queue[i]].style.cssText = (orientation == \"right\" &amp;&amp; !odd &amp;&amp; i == last) ? css[i+1] : css[i]; &#125;&#125; 修复后的效果如下： count 效果图 地址 2 https://leeenx.github.io/mobile-swiper/index.html?count=2 4 https://leeenx.github.io/mobile-swiper/index.html?count=4 结语感谢阅读完本文章的读者。本文最终实现的 swiper 笔者托管在 Github 仓库，有兴趣的读者可以看一下：https://github.com/leeenx/mobile-swiper 希望对你们有帮助。","pubDate":"Mon, 17 Jul 2017 05:23:19 GMT","guid":"https://aotu.io/notes/2017/07/17/design-a-swiper/","category":"Web开发"},{"title":"2D圆形随机分布","link":"https://aotu.io/notes/2017/07/10/Random-Circles/","description":"如何画出又快又多的圈圈。","pubDate":"Mon, 10 Jul 2017 02:11:34 GMT","guid":"https://aotu.io/notes/2017/07/10/Random-Circles/","category":"Web开发"},{"title":"用Web技术实现移动监测","link":"https://aotu.io/notes/2017/06/29/motion-detection/","description":"本文将阐述如何通过 Web 技术实现简易的移动监测效果，并附上一些有意思的案例。 移动侦测，英文翻译为“Motion detection technology”，一般也叫运动检测，常用于无人值守监控录像和自动报警。通过摄像头按照不同帧率采集得到的图像会被 CPU 按照一定算法进行计算和比较，当画面有变化时，如有人走过，镜头被移动，计算比较结果得出的数字会超过阈值并指示系统能自动作出相应的处理。——百度百科 由上述引用语句可得出“移动监测”需要以下要素： 一个拥有摄像头的计算机 用于判断移动的算法 移动后的处理 注：本文涉及的所有案例均基于 PC/Mac 较新版本的 Chrome / Firefox 浏览器，部分案例需配合摄像头完成，所有截图均保存在本地。 对方不想和你说话，并向你扔来一个链接： 体验链接&gt;&gt; 综合案例 该案例有以下两个功能： 拍好 POST 后的 1 秒会进行拍照 静止 1 秒后音乐会停止，产生移动会恢复播放状态 上述案例也许并不能直接体现出『移动监测』的实际效果和原理，下面再看看这个案例。 体验链接&gt;&gt; 像素差异 案例的左侧是视频源，而右侧则是移动后的像素处理（像素化、判断移动和只保留绿色等）。 因为是基于 Web 技术，所以视频源采用 WebRTC，像素处理则采用 Canvas。 视频源不依赖 Flash 或 Silverlight，我们使用 WebRTC (Web Real-Time Communications) 中的 navigator.getUserMedia() API，该 API 允许 Web 应用获取用户的摄像头与麦克风流（stream）。 示例代码如下：1234567891011121314151617181920&lt;!-- 若不加 autoplay，则会停留在第一帧 --&gt;&lt;video id=\"video\" autoplay&gt;&lt;/video&gt;// 具体参数含义可看相关文档。const constraints = &#123; audio: false, video: &#123; width: 640, height: 480 &#125;&#125;navigator.mediaDevices.getUserMedia(constraints) .then(stream =&gt; &#123; // 将视频源展示在 video 中 video.srcObject = stream &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) 对于兼容性问题，Safari 11 开始支持 WebRTC 了。具体可查看 caniuse。 像素处理在得到视频源后，我们就有了判断物体是否移动的素材。当然，这里并没有采用什么高深的识别算法，只是利用连续两帧截图的像素差异来判断物体是否发生移动（严格来说，是画面的变化）。 截图获取视频源截图的示例代码：123456789101112const video = document.getElementById('video')const canvas = document.createElement('canvas')const ctx = canvas.getContext('2d')canvas.width = 640canvas.height = 480// 获取视频中的一帧function capture () &#123; ctx.drawImage(video, 0, 0, canvas.width, canvas.height) // ...其它操作&#125; 得出截图间的差异对于两张图的像素差异，在 凹凸实验室 的 《“等一下，我碰！”——常见的2D碰撞检测》 这篇博文中所提及的“像素检测”碰撞算法是解决办法之一。该算法是通过遍历两个离屏画布（offscreen canvas）同一位置的像素点的透明度是否同时大于 0，来判断碰撞与否。当然，这里要改为『同一位置的像素点是否不同（或差异小于某阈值）』来判断移动与否。 但上述方式稍显麻烦和低效，这里我们采用 ctx.globalCompositeOperation = &#39;difference&#39; 指定画布新增元素（即第二张截图与第一张截图）的合成方式，得出两张截图的差异部分。 体验链接&gt;&gt; 示例代码：1234567891011function diffTwoImage () &#123; // 设置新增元素的合成方式 ctx.globalCompositeOperation = 'difference' // 清除画布 ctx.clearRect(0, 0, canvas.width, canvas.height) // 假设两张图像尺寸相等 ctx.drawImage(firstImg, 0, 0) ctx.drawImage(secondImg, 0, 0)&#125; 两张图的差异 体验上述案例后，是否有种当年玩“QQ游戏《大家来找茬》”的感觉。另外，这个案例可能还适用于以下两种情况： 当你不知道设计师前后两次给你的设计稿有何差异时 想查看两个浏览器对同一个网页的渲染有何差异时 何时为一个“动作”由上述“两张图像差异”的案例中可得：黑色代表该位置上的像素未发生改变，而像素越明亮则代表该点的“动作”越大。因此，当连续两帧截图合成后有明亮的像素存在时，即为一个“动作”的产生。但为了让程序不那么“敏感”，我们可以设定一个阈值。当明亮像素的个数大于该阈值时，才认为产生了一个“动作”。当然，我们也可以剔除“不足够明亮”的像素，以尽可能避免外界环境（如灯光等）的影响。 想要获取 Canvas 的像素信息，需要通过 ctx.getImageData(sx, sy, sw, sh)，该 API 会返回你所指定画布区域的像素对象。该对象包含 data、width、height。其中 data 是一个含有每个像素点 RGBA 信息的一维数组，如下图所示。 含有 RGBA 信息的一维数组 获取到特定区域的像素后，我们就能对每个像素进行处理（如各种滤镜效果）。处理完后，则可通过 ctx.putImageData() 将其渲染在指定的 Canvas 上。 扩展：由于 Canvas 目前没有提供“历史记录”的功能，如需实现“返回上一步”操作，则可通过 getImageData 保存上一步操作，当需要时则可通过 putImageData 进行复原。 示例代码：1234567891011121314151617181920let imageScore = 0const rgba = imageData.datafor (let i = 0; i &lt; rgba.length; i += 4) &#123; const r = rgba[i] / 3 const g = rgba[i + 1] / 3 const b = rgba[i + 2] / 3 const pixelScore = r + g + b // 如果该像素足够明亮 if (pixelScore &gt;= PIXEL_SCORE_THRESHOLD) &#123; imageScore++ &#125;&#125;// 如果明亮的像素数量满足一定条件if (imageScore &gt;= IMAGE_SCORE_THRESHOLD) &#123; // 产生了移动&#125; 在上述案例中，你也许会注意到画面是『绿色』的。其实，我们只需将每个像素的红和蓝设置为 0，即将 RGBA 的 r = 0; b = 0 即可。这样就会像电影的某些镜头一样，增加了科技感和神秘感。 体验地址&gt;&gt; 示例代码：12345678const rgba = imageData.datafor (let i = 0; i &lt; rgba.length; i += 4) &#123; rgba[i] = 0 // red rgba[i + 2] = 0 // blue&#125;ctx.putImageData(imageData, 0, 0) 将 RGBA 中的 R 和 B 置为 0 跟踪“移动物体”有了明亮的像素后，我们就要找出其 x 坐标的最小值与 y 坐标的最小值，以表示跟踪矩形的左上角。同理，x 坐标的最大值与 y 坐标的最大值则表示跟踪矩形的右下角。至此，我们就能绘制出一个能包围所有明亮像素的矩形，从而实现跟踪移动物体的效果。 找出跟踪矩形的左上角和右下角 体验链接&gt;&gt; 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function processDiff (imageData) &#123; const rgba = imageData.data let score = 0 let pixelScore = 0 let motionBox = 0 // 遍历整个 canvas 的像素，以找出明亮的点 for (let i = 0; i &lt; rgba.length; i += 4) &#123; pixelScore = (rgba[i] + rgba[i+1] + rgba[i+2]) / 3 // 若该像素足够明亮 if (pixelScore &gt;= 80) &#123; score++ coord = calcCoord(i) motionBox = calcMotionBox(montionBox, coord.x, coord.y) &#125; &#125; return &#123; score, motionBox &#125;&#125;// 得到左上角和右下角两个坐标值function calcMotionBox (curMotionBox, x, y) &#123; const motionBox = curMotionBox || &#123; x: &#123; min: coord.x, max: x &#125;, y: &#123; min: coord.y, max: y &#125; &#125; motionBox.x.min = Math.min(motionBox.x.min, x) motionBox.x.max = Math.max(motionBox.x.max, x) motionBox.y.min = Math.min(motionBox.y.min, y) motionBox.y.max = Math.max(motionBox.y.max, y) return motionBox&#125;// imageData.data 是一个含有每个像素点 rgba 信息的一维数组。// 该函数是将上述一维数组的任意下标转为 (x,y) 二维坐标。function calcCoord(i) &#123; return &#123; x: (i / 4) % diffWidth, y: Math.floor((i / 4) / diffWidth) &#125;&#125; 在得到跟踪矩形的左上角和右下角的坐标值后，通过 ctx.strokeRect(x, y, width, height) API 绘制出矩形即可。 1234567ctx.lineWidth = 6ctx.strokeRect( diff.motionBox.x.min + 0.5, diff.motionBox.y.min + 0.5, diff.motionBox.x.max - diff.motionBox.x.min, diff.motionBox.y.max - diff.motionBox.y.min) 这是理想效果，实际效果请打开 体验链接 扩展：为什么上述绘制矩形的代码中的 x、y 要加 0.5 呢？一图胜千言： 性能缩小尺寸在上一个章节提到，我们需要通过对 Canvas 每个像素进行处理，假设 Canvas 的宽为 640，高为 480，那么就需要遍历 640 * 480 = 307200 个像素。而在监测效果可接受的前提下，我们可以将需要进行像素处理的 Canvas 缩小尺寸，如缩小 10 倍。这样需要遍历的像素数量就降低 100 倍，从而提升性能。 体验地址&gt;&gt; 示例代码：12345678const motionCanvas // 展示给用户看const backgroundCanvas // offscreen canvas 背后处理数据motionCanvas.width = 640motionCanvas.height = 480backgroundCanvas.width = 64backgroundCanvas.height = 48 尺寸缩小 10 倍 定时器我们都知道，当游戏以『每秒60帧』运行时才能保证一定的体验。但对于我们目前的案例来说，帧率并不是我们追求的第一位。因此，每 100 毫秒（具体数值取决于实际情况）取当前帧与前一帧进行比较即可。 另外，因为我们的动作一般具有连贯性，所以可取该连贯动作中幅度最大的（即“分数”最高）或最后一帧动作进行处理即可（如存储到本地或分享到朋友圈）。 延伸至此，用 Web 技术实现简易的“移动监测”效果已基本讲述完毕。由于算法、设备等因素的限制，该效果只能以 2D 画面为基础来判断物体是否发生“移动”。而微软的 Xbox、索尼的 PS、任天堂的 Wii 等游戏设备上的体感游戏则依赖于硬件。以微软的 Kinect 为例，它为开发者提供了可跟踪最多六个完整骨骼和每人 25 个关节等强大功能。利用这些详细的人体参数，我们就能实现各种隔空的『手势操作』，如画圈圈诅咒某人。 下面几个是通过 Web 使用 Kinect 的库： DepthJS：以浏览器插件形式提供数据访问。 Node-Kinect2： 以 Nodejs 搭建服务器端，提供数据比较完整，实例较多。 ZigFu：支持 H5、U3D、Flash，API较为完整。 Kinect-HTML5：Kinect-HTML5 用 C# 搭建服务端，提供色彩数据、深度数据和骨骼数据。 通过 Node-Kinect2 获取骨骼数据 文章至此就真的要结束了，如果你想知道更多玩法，请关注 凹凸实验室。同时，也希望大家发掘更多玩法。 参考资料 使用HTML5开发Kinect体感游戏 MOTION DETECTION WITH JAVASCRIPT","pubDate":"Thu, 29 Jun 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/06/29/motion-detection/","category":"Web开发"},{"title":"流式分页方案探索","link":"https://aotu.io/notes/2017/06/27/infinite-scrolling/","description":"分页类型首先我们要简单认识下，何谓流式分页。分页一般用于对信息列表进行分段。根据具体功能及交互方式的不同，大致可将分页分为两种类型：传统分页和流式分页。 传统分页传统分页多用于 PC 页面，最常见于搜索结果页，如我们常用的搜索引擎 Google： 还有百度： 在京东的搜索结果页中，也可见传统分页的影子： 而在移动端页面中，限制于点击区域的大小，因此较少使用传统分页。 结合上述例子，我们可分析出，传统分页有如下几个特点： 通过页码进行分页 通过点击上/下页按钮可实现页面切换 通过点击页码可实现页面切换 可直接跳转至指定页面 多用于 PC 端 流式分页流式分页在 PC 端和移动端都有使用。PC 页面可用于对多个商品信息的展示，通过滚动的方式加载更多商品信息，如：京东首页还没逛够、发现好货等。而 H5 中，通过点击/上拉的方式来加载列表信息，也是很多见的，如京东首页为您推荐就是使用点击加上拉的方式：腾讯新闻则是通过点击的方式来加载更多信息： 结合上述例子，我们可分析出，流式分页有如下几个特点： 通过滚动/上拉/点击等方式加载新一页 无页码 无上/下页按钮 不可跳转至指定页面 pc端和移动端均有使用 传统分页和流式分页都有各自明显的优缺点，非本文重点，故不展开。有兴趣的同学可前往《Infinite Scrolling vs. Pagination》（Nick Babich 作 / Ruixi 译）查看。 流式分页的实现方案流式分页在前后端都可以实现，需根据实际情况进行决策。下面对前后端的实现及适用场景进行详细介绍。 前端分页的实现在前端分页的实现中，通过接口一次性获取列表的所有内容，根据数据的总长度和每页需展示的个数计算总页数；之后的每次加载操作（滚动/点击）中，依次执行数据截取、DOM 渲染、插入结构的过程，直至最后一页。 前端分页流程图如下： 前文提到的京东首页还没逛够就是采用前端分页的方式。在前后端的配合中，后端为前端提供如下接口：1diviner.jd.com/diviner?p=610009&amp;callback=jsonpCallbackMoreGood&amp;lid=1&amp;lim=100&amp;ec=utf-8 其中相关的参数列表如下： 参数 含义 备注 lim / limit 返回数据个数 由前端根据需要传参，或由后端设置默认值 返回数据如下： 前端将返回的 100 个数据分成两段，依次在需要加载时进行渲染插入操作。 后端根据前端的传参或约定好的数据个数，对数据进行查找。我们使用 Mongo 操作语句（后文提到的后端操作均为 Mongo）来简单表示后端的操作：1Model.find().limit(lim) 前端分页的方法适用于数据较少/分页较少的情况。 后端分页的实现在后端分页的实现中，在加载时，前端通过页码来拉数据，若返回非空数组，则进行 DOM 渲染，插入接口的操作；若返回空数组，则说明当前请求的为最后一页的数据，无需再发送请求。 后端分页流程图如下： 前文提到的发现好货就是采用后端分页的方式。在前后端的配合中，后端为前端提供如下接口：1https://ai.jd.com/index_new.php?app=Discovergoods&amp;action=getDiscZdmGoodsList&amp;callback=listCallback&amp;page=1 其中相关的参数列表如下： 参数 含义 备注 page 当前页数 由前端传参 pageSize / limit 每页数据个数 由前端根据需要传参，或由后端设置默认值 返回数据如下：非空数组： 空数组： 前端记录页数，在加载时根据返回的数据进行渲染插入操作。 后端根据前端对当前页数的传参以及每页数据个数的设置，对数据进行查找： 12const offset = (page-1) * pageSize // 跳过的个数Model.find().skip(offset).limit(pageSize) 后端分页的方法适用于数据较多/分页较多的情况。 后端分页的问题与优化存在的问题1. 数据缺失假设现在需要倒序取 20 条数据，每页展示 10 条。取第 1 页时，客户端通过page=1 pageSize=10传参，获取 20 号-11 号的数据；此时恰好另一客户端删除 17 号数据；取第 2 页时，客户端通过page=2 pageSize=10传参，offset 由原来的 20-11 变成 20-10，导致最后获取 9 号-1 号的数据。最终展示结果为 19 条，10 号数据缺失。具体过程如下： 2. 数据重复假设现在需要倒序取 20 条数据，每页展示 10 条。取第 1 页时，客户端通过page=1 pageSize=10传参，获取 20 号-11 号的数据；此时恰好另一客户端添加 21 号数据；取第 2 页时，客户端通过page=2 pageSize=10传参，offset 由原来的 20-11 变成 21-12，导致最后获取 11 号-2 号的数据。最终展示结果为 20 条，11 号数据重复。具体过程如下： 优化方案1. 使用缓存后端查询数据时，不直接对数据库进行操作，而是查找缓存的数据。缓存的方法有很多，这里介绍一种“按时间分片式缓存”的方法。前端请求数据时，除了前面提到的page和pageSize参数外，还要再传入一个timestamp参数： 请求第 1 页数据时，timestamp 传 0，服务端检查将当前系统时间赋值给 timestamp 返回 请求第 2，3，…n 页数据时，将第 1 步系统返回的 timestamp 传入 其中相关的参数列表如下： 参数 含义 备注 page 当前页数 由前端传参 pageSize 每页数据个数 由前端根据需要传参，或由后端设置默认值 timestamp 时间戳 由前端传参 后端处理时，对传入的timestamp进行判断： 若timestamp为 0，生成当前时间对应的缓存，如“data_1498705088000”，并返回前端所需数据 若timestamp不为 0 且对应的缓存不存在，返回“刷新数据”的提示 若timestamp不为 0 且有对应的缓存，则返回前端所需数据 具体过程如下：（图片来源：《浅谈APP流式分页服务端设计》） 2. 游标式分页 客户端记录当前分页的最后一条数据的 ID 请求下一页的时候，从这个 ID 开始获取一页大小的内容 其中相关的参数列表如下： 参数 含义 备注 curcor 最后一个 ID 由前端传参 pageSize 每页数据个数 由前端根据需要传参，或由后端设置默认值 后端根据前端对最后一个 ID 的传参以及每页数据个数的设置，对数据进行查找：1Model.find(&#123;id: &#123;$gt: cursor&#125;&#125;).limit(pageSize) 优点： 能够避免数据重复/遗漏 无需计算offset，性能更稳定 缺点： 只适用于按照时间追加的方式的简单排序 3. 一次性下发 ID 请求第 1 页数据之前/时先缓存所有 ID 列表 请求第 2，3，…n 页数据时，只需传入相关的 ID 列表参数 如前文提到的腾讯新闻的例子，第一次请求时（除首屏直出数据），请求所有数据的 ID 和第 1 页的数据，接口如下：1http://xw.qq.com/service/api/proxy?key=Xw@2017Mmd&amp;charset=GBK&amp;url=http://openapi.inews.qq.com/getQQNewsIndexAndItems?chlid=news_news_top&amp;refer=mobilewwwqqcom&amp;otype=jsonp&amp;t=1498706343475 返回数据如下： 之后的请求数据，将所需的 ID 列表传入，获取对应的详细信息，接口如下：1http://xw.qq.com/service/api/proxy?key=Xw@2017Mmd&amp;charset=GBK&amp;url=http://openapi.inews.qq.com/getQQNewsNormalContent?ids=20170604A063AG00,20170604A05SKQ00,20170604A05PBT00,NEW2017060403772906,NEW2017060403765707,NEW2017060403278705,20170604A06CMP00,20170604A03ZEU00,20170604A04P5900,NEW2017060402106202,20170603A07E0700,20170604A04WBM00,NEW2017060403031208,20170604A02X9900,20170604A03U6600,20170604A040JX00,20170604A04TE200,NEW2017060403727300,NEW2017060403727800,20170604A03I8200&amp;refer=mobilewwwqqcom&amp;otype=jsonp&amp;t=1496603487427 返回数据如下： 适用于 id 列表不会很大（数百条数据）的业务场景 4. 客户端排除 在客户端中保存已加载记录的 ID 每次请求完数据时，先进行数据去重 若去重数据较多，则考虑再请求下一页的数据 优点： 确保不会出现重复的数据 不改动服务器端的原有逻辑 缺点： 只适用于列表数据添加不是很频繁的情况 参考文档 《浅谈APP流式分页服务端设计》 《浅谈单页应用中前端分页的实现方案》 《APP后端分页设计》 《Infinite Scrolling vs. Pagination》 《瀑布流下拉加载更多导致数据重复怎么办》","pubDate":"Tue, 27 Jun 2017 13:00:00 GMT","guid":"https://aotu.io/notes/2017/06/27/infinite-scrolling/","category":"Web开发"},{"title":"URL编码的奥秘","link":"https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/","description":"URL编码的世界很精彩，你不过来看一下么？","pubDate":"Thu, 15 Jun 2017 02:41:24 GMT","guid":"https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/","category":"Web开发"},{"title":"10个你可能不知道的前端PS技巧","link":"https://aotu.io/notes/2017/06/09/ps-tricks/","description":"PS是各位前端开发者的基础技能，高效利用PS不仅能提高工作效率，更能带来身心上的愉悦——Jack Ma 在前端切图工作里，本质来说就是“选择图层-获取信息、编辑图层-导出图层”的过程，本文主要介绍在这个过程里的一些技巧。 1、面板这里的面板指的是在顶部主菜单“窗口”下可开启的窗口。最常用的几个窗口必属“属性”、“信息”、“图层”，屏幕够大的同学建议把它们都展开在界面右边。那为什么说这几个面板很常用呢？下面会慢慢介绍到。 2、选择图层在移动工具(V)下这个操作非常常用：option+右键/command+左键(windows:alt+右键)，在psd里快速选定图层，点哪选哪。不需要勾选“自动选择”图层选项也能快速选择图层。 而笔者比较喜欢用“option+右键”而不是“command+左键”，因为这个操作经常需要结合视图缩放(option+滚轮，windows:alt+滚轮)，这样来回切换会更方便。 3、属性面板结合快速选择图层，属性面板可以展示不少图层信息，而这些信息在开发中非常有用： 可查看文本的字体大小和颜色等 可查看形状工具(U)画出的形状的填充色和圆角等信息 可查看智能对象的宽高 可以看出属性面板主要展示的是PS比较“原生”的对象的信息。 4、信息面板“信息面板”和“属性面板”类似，只不过前者展现的信息和后者不太一样。 比如，快速选中图层后，如果在“属性面板”不能看到图层的宽高信息，可以command+T(windows:ctrl+T)打开变形操作，在“信息”面板一定可以看到图层的宽高信息，看完后记得按esc顺手退出变形工具以免不小心误操作。 妈妈再也不用担心我矩形选框工具(M)取大概估算元素的宽高值啦…… 5、吸管工具(I)这个工具最基本的功能是吸取图层颜色，这里有几个技巧可以说一下： 左键点击吸取，颜色会实时展示在“信息面板上”； 设计稿经常会看到一些不太明显的渐变色背景色的模块，怎么才能快速知道这是属于渐变色还是纯色的块？按住左键拖动吸管，颜色信息展示在“信息面板”上，通过观察即可知道到底要用background-color还是linear-gradient； 右键需要获取的颜色点，然后会出现菜单，最后一项是“拷贝颜色的十六进制代码”，这里可以快速拷贝色值供css代码用； 如果图层有不透明度，请记得先把不透明度恢复到100%才可以吸取，否则色值会不正确，右键拷贝的色值也会不对； 按住shift键然后吸取，这样会吸取多个色值，并且依次记录在“信息面板”上，这个用于对比色值很有用，在图上相应位置也会标识出顺序，如下图： 6、获取margin的另一种方式在移动工具下(V)，选中图层后，长按command(windows:长按ctrl)键，然后移动鼠标，此时鼠标停留处的图层会出现与选中图层之间的一些紫色标注的一些距离信息，这个用于获取margin比较有用。 7、复制css在图层面板，右键图层，有个“复制css”选项。这个功能在PS里很早就加进来了，可能很多同学都觉得挺鸡肋的，觉得这是给设计师学习css用的。但是其实里面的有一些信息还是挺有用的，可减少一些工作量，比如下面一段css： 123456789101112131415161718192021222324.圆角矩形_584 &#123; border-radius: 15px; background-color: rgb(0, 0, 0); opacity: 0.302; box-shadow: 6px 10.392px 121.83px 9.17px rgba(79, 48, 193, 0.004); position: absolute; left: 283px; top: 306px; width: 136px; height: 32px; z-index: 34;&#125;.矩形_1 &#123; background-image: -moz-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); background-image: -webkit-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); background-image: -ms-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); position: absolute; left: 348px; top: 572px; width: 113px; height: 78px; z-index: 25;&#125; 我们可以用到里面的圆角、背景色、透明度、阴影、宽高、渐变信息，不过说实话代码写法真的挺丑的，比如渐变那个，要进行一些人工的干预处理。不过总归可以少输入一点代码减少工作量，有些信息也不用麻烦各种手段去取、去猜…… 一般来说只是形状工具(U)画出来的形状才会有比较有用的信息，如果是图片类的图层拷贝出来的信息一般只有宽高信息可以用。 8、复制图层到新文件编辑经常会遇到一些设计稿特别大、而我们又不得不进行一些编辑的情况，很容易会出现下面的情况： 所以，从现在起你就应该这样做： 选中图层(组) 图层面板右键图层，选择“复制图层” 在弹出的面板的文档单选框里选择“新建”，如下图 接下来就可以看到在新文件里放置了该图层，然后就可以放心的进行“裁剪、变形、合并图层”等操作了……真的一点都不卡。 9、资源生成器这个功能在最新的几个版本PS里都得到支持，用于切图非常方便。具体操作方法： 首先打开设置，在“增效工具”下，勾选“启用生成器”；然后在主菜单的“文件”-“生成”，勾选“图像资源” 在图层面板选择要导出的图层，把文件名改为如“icon.png”带图片扩展名的图层名，然后就完成了资源生成的全部步骤，就这么简单。生成的资源在文件同目录下、以“-assets”结尾的文件夹里。 图层名可以怎么设置呢？下面列出了一些例子。 图层名 导出图片 logo.png 生成png-32，含透明通道 logo.png8 生成png-8 logo.png24 生成png-24，不含透明通道 img/logo.png24 资源保存在img下 logo.jpg 质量90% logo.jpg8 质量80% logo.jpg5、logo.jpg50% 质量50% 50% logo@1x.png 宽高为原图的50% 50% logo@1x.png + 100% logo@2x.png 用“+”或“,”分割可生成多份资源 图片格式还可以是gif、svg甚至webp等。可以看出资源生成器非常强大，甚至图层编辑后也会同步更新到导出的资源里。要注意图层名要唯一，否则资源会被覆盖。 以上只是一部分配置，有兴趣的同学可以参考文后资料看详细的语法。 10、微调导出的icon网页用rem单位的同学都应该知道，如果png的icon的宽高四周没有空出1像素的透明空白，网页上的icon效果四周很可能会被“吃掉”一点点。所以在icon四周留出1像素的空白很必要。“资源生成器”不能提供这种设置，但是有以下方法可以做到： 图层面板，选中图层(可按shift选多个图层，批量处理相似图层)，右键，选择“导出为” 在弹出面板可设置画布大小，宽高可设置比原来的尺寸大2像素即可，2像素会分配到上下左右各1像素。如下图： 参考资料资源生成器语法 https://helpx.adobe.com/photoshop/using/generate-assets-layers.html#specify-quality-and-size-parameters","pubDate":"Fri, 09 Jun 2017 08:30:00 GMT","guid":"https://aotu.io/notes/2017/06/09/ps-tricks/","category":"资源合集"},{"title":"canvas 图像旋转与翻转姿势解锁","link":"https://aotu.io/notes/2017/05/25/canvas-img-rotate-and-flip/","description":"多图预警，数学不好可直接跳至文末小结。 需求背景从一个游戏需求说起： 技术选型：canvas上图所展示的游戏场景，“可乐瓶”里有多个“气泡”，需要设置不同的动画效果，且涉及 deviceOrientation 的交互，需要有大量计算改变元素状态。从性能方面考虑，canvas 是不二的选择。 技术点：canvas 绘制图像通过对游戏场景的进一步分析，可见场景中的“气泡”元素形状都是相同的，且不规则，通过 canvas 直接绘制形状实现成本较高，因此需要在 canvas 上绘制图像。 技术点：canvas 图像旋转与翻转虽然“气泡”元素是相同的，可以使用相同的图像，但图像需要多个角度/多个方向展示，因此需要对图像进行相应的旋转与翻转（镜像），这也是本文所要介绍的重点。 后文代码以下图左侧绿框的“气泡”为示例，右侧展示了场景中用到的两个图像： 认识 canvas 坐标系canvas 上图像的旋转和翻转，常见的做法是将 canvas 坐标系统进行变换。因此，我们需要先认识 canvas 坐标系统：由上图可得，canvas 2D 环境中坐标系统和 Web 的坐标系统是一致的，有以下几个特点： 坐标原点 (0,0) 在左上角 X坐标向右方增长 Y坐标向下方延伸 回到上述需求中，我们获取 canvas 对象并设置相应的宽高：1&lt;canvas id='myCanvas'&gt;&lt;/canvas&gt; 123456// 获取 canvas 对象var canvas = document.getElementById('myCanvas')canvas.width = 750canvas.height = 1054// 获取 canvas 2D 上下文对象var ctx = canvas.getContext('2d') 此时，canvas 的坐标系统如下图所示： 在 canvas 上绘制图像在 canvas 上绘制图像，可以使用 drawImage() 方法，语法如下（详细用法参见 MDN）：123void ctx.drawImage(image, dx, dy);void ctx.drawImage(image, dx, dy, dWidth, dHeight);void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 需要注意的是，图像必须加载完毕，才能绘制到 canvas 上，否则会出现空白：123456var img = new Image()img.src = 'xxxxxxx.png'img.onload = function() &#123; // 绘制图像 ctx.drawImage(img, 512, 220, 160, 192);&#125; 此时，便可以 canvas 上看到一个未旋转/翻转的“气泡”图像，如下图所示： canvas 坐标变换接下来，我们再来了解 canvas 坐标的变换。上述需求仅涉及 2D 绘制上下文，因此仅介绍 2D 绘制上下文支持的各种变换： 平移 translate： 1ctx.translate(x, y) translate() 方法接受两个参数。x 是左右偏移量，y 是上下偏移量。 旋转 rotate： 1ctx.rotate(angle) rotate() 方法只接受一个参数。旋转的角度 angle，它是顺时针方向的，以弧度为单位的值。 缩放 scale： 1ctx.scale(x, y) scale() 方法接受两个参数。x 和 y 分别是横轴和纵轴的缩放因子。其缩放因子默认是 1，如果比 1 小是缩小，如果比 1 大则放大。 变形 transform： 1ctx.transform (a, b, c, d, e, f) transform() 方法是对当前坐标系进行矩阵变换。 1ctx.setTransform (a, b, c, d, e, f) setTransform() 方法重置变形矩阵。先将当前的矩阵重置为单位矩阵（即默认的坐标系），再用相同的参数调用 transform() 方法设置矩阵。 以上两个方法均接受六个参数，具体如下： 参数 含义 a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 图像旋转的实现上图所示“气泡”，宽为 160，高为 192，x 轴方向距离原点 512，y 轴方向距离原点 220，逆时针旋转 35 度。要绘制该“气泡”，需要先将坐标系平移（translate），再旋转（rotate）。具体实现步骤如下： save() 方法与 restore() 方法： save() 方法用来保存 Canvas 状态的，没有参数。每一次调用 save() 方法，当前的状态就会被推入栈中保存起来。当前状态包括： 当前应用的变形（移动/旋转/缩放） strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值 当前的裁切路径（clipping path） restore() 方法用来恢复 Canvas 状态，没有参数。每一次调用 restore() 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。 状态保存在栈中，可以嵌套使用 save() 与 restore()。 图像翻转的实现上图所示“气泡”，宽为 160，高为 192，x 轴方向距离原点 172，y 轴方向距离原点 365，顺时针旋转 35 度。要绘制该“气泡”，需要先将坐标系统平移（translate），翻转（scale），平移（translate），再旋转（rotate）。具体实现步骤如下：至此，实现了“气泡”的镜像翻转，但翻转后的“气泡”还需要旋转特定的角度，在方法一的基础上继续对坐标系统进行变换：以上操作中进行了两次平移（translate）操作，可以进行合并简化： 坐标系统的矩阵变换前文介绍了 2D 绘制上下文变形（transform）变换，实际是直接修改变换的矩阵，它可以实现前面介绍的平移（translate）／旋转（rotate）／缩放（ scale）变换，还可以实现切变/镜像反射变换等。矩阵计算遵循数学矩阵公式规则：由上公式可得：12x' = ax + cy + ey' = bx + dy + f 矩阵变换可实现以下变换效果： 平移 translate： 12x' = 1x+0y+tx = x+txy' = 0x+1y+ty = y+ty 旋转 rotate： 12x' = x*cosθ-y*sinθ+0 = x*cosθ-y*sinθy' = x*sinθ+y*cosθ+0 = x*sinθ+y*cosθ 缩放 scale： 12x' = Sx*x+0y+0 = Sx*xy' = 0x+Sy*y+0 = Sy*y 切变 12x' = x+y*tan(θx)+0 = x+y*tan(θx)y' = x*tan(θy)+y+0 = x*tan(θy)+y 镜像反射 12345// 定义(ux,uy)为直线(y=kx)方向的单位向量ux=1/sqrt(1+k^2)uy=k/sqrt(1+k^2)x' = (2*ux^2-1)*x+2*ux*uy*yy' = 2*ux*uy*x+(2*uy^2-1)*y 结合上述公式，可推导出图像旋转和翻转的矩阵变换实现： 图像旋转： 图像翻转： 图像镜像反射（翻转+旋转）： 像素操作实现图像翻转除了坐标系统变换，canvas 的像素操作同样可以实现图像的翻转。首先需要了解下 getImageData() 方法（详细用法参见MDN）和 putImageData()（详细用法参见MDN）方法： getImageData()CanvasRenderingContext2D.getImageData() 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为 (sx, sy)、宽为 sw、高为 sh。 1ImageData ctx.getImageData(sx, sy, sw, sh); putImageData()CanvasRenderingContext2D.putImageData() 是 Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法。 如果提供了脏矩形，只能绘制矩形的像素。 12void ctx.putImageData(imagedata, dx, dy);void ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight); 水平翻转实现：12345678910111213141516171819202122// 绘制图像ctx.drawImage(img, x, y, width, height)// 获取 img_data 数据var img_data = ctx.getImageData(x, y, width, height), i, i2, t, h = img_data.height, w = img_data.width, w_2 = w / 2;// 将 img_data 的数据水平翻转for (var dy = 0; dy &lt; h; dy ++) &#123; for (var dx = 0; dx &lt; w_2; dx ++) &#123; i = (dy &lt;&lt; 2) * w + (dx &lt;&lt; 2) i2 = ((dy + 1) &lt;&lt; 2) * w - ((dx + 1) &lt;&lt; 2) for (var p = 0; p &lt; 4; p ++) &#123; t = img_data.data[i + p] img_data.data[i + p] = img_data.data[i2 + p] img_data.data[i2 + p] = t &#125; &#125;&#125;// 重绘水平翻转后的图片ctx.putImageData(img_data, x, y) 小结至此，小编的数学姿势又恢复到了高考水平。 图像旋转： 基础变换法： 12345ctx.save()ctx.translate(x + width / 2, y + height / 2)ctx.rotate(angle * Math.PI / 180)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 矩阵变换法： 12345ctx.save()var rad = angle * Math.PI/180ctx.transform( Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), x + width / 2, y + height / 2)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 图像翻转： 基础变换法： 123456// 方法一ctx.save()ctx.translate(canvasWidth, 0)ctx.scale(-1, 1)ctx.drawImage(img, canvasWidth-width-x, y, width, height)ctx.restore() 12345// 方法二ctx.save()ctx.scale(-1, 1)ctx.drawImage(img, -width-x, y, width, height)ctx.restore() 矩阵变换法： 12345// 方法一ctx.save()ctx.transform(-1, 0, 0, 1, canvasWidth, 0)ctx.drawImage(img, canvasWidth-width-x, y, width, height)ctx.restore() 12345// 方法二ctx.save()ctx.transform(-1, 0, 0, 1, 0, 0)ctx.drawImage(img, -width-x, y, width, height)ctx.restore() 像素操作法： 123456789101112131415161718ctx.drawImage(img, x, y, width, height)var img_data = ctx.getImageData(x, y, width, height), i, i2, t, h = img_data.height, w = img_data.width, w_2 = w / 2;for (var dy = 0; dy &lt; h; dy ++) &#123; for (var dx = 0; dx &lt; w_2; dx ++) &#123; i = (dy &lt;&lt; 2) * w + (dx &lt;&lt; 2) i2 = ((dy + 1) &lt;&lt; 2) * w - ((dx + 1) &lt;&lt; 2) for (var p = 0; p &lt; 4; p ++) &#123; t = img_data.data[i + p] img_data.data[i + p] = img_data.data[i2 + p] img_data.data[i2 + p] = t &#125; &#125;&#125;ctx.putImageData(img_data, x, y) 图像镜像对称（翻转+旋转）： 基础变换法： 123456ctx.save()ctx.scale(-1, 1)ctx.translate(-width/2-x, y+height/2) ctx.rotate(-angle * Math.PI / 180)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 矩阵变换法： 1234567ctx.save()var k = Math.tan( (180-angle)/2 * Math.PI / 180 )var ux = 1 / Math.sqrt(1 + k * k)var uy = k / Math.sqrt(1 + k * k)ctx.transform( (2*ux*ux-1), 2*ux*uy, 2*ux*uy, (2*uy*uy-1), x + width/2, y + height/2 )ctx.drawImage(img, -width/2, -height/2, width, height)ctx.restore() 参考文章 《W3cplus - CANVAS 系列》 《html5 canvas.transform[转]》 《html5 canvas 学习笔记》 《在HTML5中翻转图片》 说明：本文讨论的 canvas 环境均为 2D 环境。若有更好的实现方式，欢迎留言告知。","pubDate":"Thu, 25 May 2017 15:00:00 GMT","guid":"https://aotu.io/notes/2017/05/25/canvas-img-rotate-and-flip/","category":"Web开发"},{"title":"一个例子上手SVG动画","link":"https://aotu.io/notes/2017/05/04/example-for-svg-animation/","description":"CSS3动画已足够强大，不过还是有一些它做不到的地方。配合SVG，让Web动效有更多的可能性。这次要做的效果是一个loading动画（如图）：其中旋转通过CSS来完成，但是旋转之后圆弧缩短变成笑脸的嘴巴需要借助SVG来实现。 Step1、声明SVG视口1&lt;svg width=\"100\" height=“100”&gt;&lt;/svg&gt; 指定一个宽高都为100像素的区域，width=”100”和width=”100px”是等价的，当然也可以使用其他的合法单位，例如cm、mm、em等。阅读器会设置一个默认的坐标系统，见图：左上角为原点，其中水平（x）坐标向右递增，垂直（y）坐标向下递增。 在没有指定的情况下，所有的的数值默认单位都是像素。 Step2、绘制购物袋购物袋由两个部分组成，先画下面的主体： 1&lt;path d=\"M 20 40 L 80 40 L 80 90 A 10 10 90 0 1 70 100 L 30 100 A 10 10 90 0 1 20 90\" style=\"fill: #e9e8ee;\" /&gt; 任何形状都可以使用路径元素画出，描述轮廓的数据放在它的d属性中。a.样式中的fill用来设置填充色。b.路径数据由命令和坐标构成: 指令 说明 M 20 40 表示移动画笔到(20,40) L 80 40 表示绘制一条线到(80, 40) A 10 10 90 0 1 70 100 绘制一个椭圆弧 圆弧命令以字母A开始，后面紧跟着7个参数，这7个参数分别用来表示： 椭圆的x半径和y半径 椭圆的x轴旋转角度 圆弧的角度小于180度，为0；大于或等于180度，则为1 以负角度绘制为0，否则为1 终点的x、y坐标 接下来绘制购物袋上面的部分 1&lt;path d=\"M 35 40 A 15 15 180 1 1 65 40\" style=\"fill: none; stroke: #e9e8ee; stroke-width: 5;” /&gt; 上面的部分是一个半圆弧，我同样用路径来画出，也可以使用基础形状来完成。样式中的stoke和stroke-width分别用来设置描边色和描边的宽度。 Step3、绘制眼睛12&lt;circle cx=“40\" cy=\"60\" r=\"2.5\" style=\"fill: #fff;\" /&gt;&lt;circle cx=\"60\" cy=\"60\" r=\"2.5\" style=\"fill: #fff;\" /&gt; 使用基础形状，画两个个小圆点。四个属性分别是位置坐标、半径和填充颜色。 Step4、绘制嘴巴1&lt;circle cx=\"50\" cy=\"70\" r=\"15\" style=\"fill: none; stroke: #fff; stroke-width: 5; stroke-linecap: round;transform: rotate(280deg); transform-origin: 50% 50%; stroke-dashoffset: -23; stroke-dasharray: 42, 95;”&gt; 嘴巴是一段圆弧，我绘制了一个圆，然后描边了其中的一段，并且做了一个旋转，来让它的角度处于正确的位置。 stroke-linecap：用来定义开放路径的终结,可选round|butt|square stroke-dasharray：用来创建虚线 stroke-dashoffset：设置虚线位置的起始偏移值，在下一步骤里，它会和stroke-dasharray一起用来实现动效。 Step5、给嘴巴部分添加动效1234567891011121314151617@keyframes mouth &#123; 0% &#123; transform: rotate(-80deg); stroke-dasharray: 60, 95; stroke-dashoffset: 0; &#125; 40% &#123; transform: rotate(280deg); stroke-dasharray: 60, 95; stroke-dashoffset: 0; &#125; 70%, 100% &#123; transform: rotate(280deg); stroke-dashoffset: -23; stroke-dasharray: 42, 95; &#125;&#125; 动画分为两个部分： 圆弧旋转 旋转之后缩短变形 在一个循环里，最后留有30%的时间保持一个停留。 Step6、给眼睛添加动画两只眼睛都是沿着圆弧运动 ，例如左眼，首先用一个路径来规定它的运动轨迹：1&lt;path id=\"eyeright\" d=\"M 40 60 A 15 15 180 0 1 60 60\" style=\"fill: none; stroke-width: 0;\" /&gt; 然后使用animateMotion来设置动画：12345678910&lt;circle class=\"eye\" cx=\"\" cy=\"\" r=\"2.5\" style=\"fill: #fff;\"&gt; &lt;animateMotion dur=\"0.8s\" repeatCount=\"indefinite\" keyPoints=\"0;0;1;1\" keyTimes=\"0;0.3;0.9;1\" calcMode=\"linear\"&gt; &lt;mpath xlink:href=\"#eyeleft\"/&gt; &lt;/animateMotion&gt;&lt;/circle&gt; dur：动画的时间 repeatCount：重复次数 keyPoints：运动路径的关键点 timePoints：时间的关键点 calcMode：控制动画的运动速率的变化，discrete | linear | paced | spline四个属性可选 mpath：指定一个外部定义的路径 Step7、将不同部位的动画组合到一起 眼睛的动画是从嘴巴旋转完成开始，到嘴巴变形完成结束，因此和嘴巴的动画一样，我设置了四个对应的关键时间点。 为了让衔接更顺畅，眼睛的动画开始比嘴巴变形开始稍微提前了一点点。 参考： MDN-SVG文档 《SVG精髓》- 人民邮电出版社","pubDate":"Thu, 04 May 2017 11:21:03 GMT","guid":"https://aotu.io/notes/2017/05/04/example-for-svg-animation/","category":"Web开发"},{"title":"利用视口单位实现适配布局","link":"https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/","description":"响应式布局的实现依靠媒体查询（ Media Queries ）来实现，选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配。即使是通过 rem 单位来实现适配，也是需要内嵌一段脚本去动态计算根元素大小。 近年来，随着移动端对视口单位的支持越来越成熟、广泛，使得我们可以尝试一种新的办法去真正地适配所有设备尺寸。 认识视口单位（ Viewport units )首先，我们要了解什么是视口。 在业界，极为推崇的一种理论是 Peter-Paul Koch (江湖人称“PPK大神”)提出的关于视口的解释——在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。 而视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。 视口单位中的“视口” 根据CSS3规范，视口单位主要包括以下4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个 视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。 用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况） 例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。 兼容性其兼容性如下图所示，可以知道：在移动端 iOS 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持。 截图来自Can I Use 截图来自X5内核－Can I Use 利用视口单位适配页面对于移动端开发来说，最为重要的一点是如何适配页面，实现多终端的兼容，不同的适配方式各有千秋，也各有缺点。 就主流的响应式布局、弹性布局来说，通过 Media Queries 实现的布局需要配置多个响应断点，而且带来的体验也对用户十分的不友好：布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。 而通过采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。 有没有办法能够解决这样的问题呢？ 答案是肯定的，通过利用视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的。 做法一：仅使用vw作为CSS单位在仅使用 vw 单位作为唯一应用的一种 CSS 单位的这种做法下，我们遵守： 1.对于设计稿的尺寸转换为vw单位，我们使用Sass函数编译 12345//iPhone 6尺寸作为设计稿基准$vw_base: 375; @function vw($px) &#123; @return ($px / 375) * 100vw;&#125; 2.无论是文本还是布局高宽、间距等都使用 vw 作为 CSS 单位 1234567891011121314151617181920212223242526.mod_nav &#123; background-color: #fff; &amp;_list &#123; display: flex; padding: vw(15) vw(10) vw(10); // 内间距 &amp;_item &#123; flex: 1; text-align: center; font-size: vw(10); // 字体大小 &amp;_logo &#123; display: block; margin: 0 auto; width: vw(40); // 宽度 height: vw(40); // 高度 img &#123; display: block; margin: 0 auto; max-width: 100%; &#125; &#125; &amp;_name &#123; margin-top: vw(2); &#125; &#125; &#125;&#125; 3.1物理像素线（也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现。 1234567891011121314151617181920.mod_grid &#123; position: relative; &amp;::after &#123; // 实现1物理像素的下边框线 content: ''; position: absolute; z-index: 1; pointer-events: none; background-color: #ddd; height: 1px; left: 0; right: 0; top: 0; @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123; -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; &#125; &#125; ...&#125; 4.对于需要保持高宽比的图，应改用 padding-top 实现 12345678910111213.mod_banner &#123; position: relative; padding-top: percentage(100/750); // 使用padding-top height: 0; overflow: hidden; img &#123; width: 100%; height: auto; position: absolute; left: 0; top: 0; &#125;&#125; 由此，我们能够实现一个常见布局的页面效果如下： 体验地址点击此处 做法二：搭配vw和rem，布局更优化这样的页面虽然看起来适配得很好，但是你会发现由于它是利用视口单位实现的布局，依赖于视口大小而自动缩放，无论视口过大还是过小，它也随着视口过大或者过小，失去了最大最小宽度的限制。 当然，你可以不在乎这样微小的不友好用户体验，但我们还是尝试下追求修复这样的小瑕疵吧。 于是，联想到不如结合rem单位来实现布局？rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过： 给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度 这样我们就能够实现对布局宽度的最大最小限制。因此，根据以上条件，我们可以得出代码实现如下： 123456789101112131415161718192021222324// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vw_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vw_design: 750;html &#123; font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125; 这里就不再给出截图，但你可以点击此处在线地址进行体验。 小结相对于做法一，个人比较推崇做法二，有以下两点原因： 第一，做法二相对来说用户视觉体验更好，增加了最大最小宽度的限制； 第二，更重要是，如果选择主流的rem弹性布局方式作为项目开发的适配页面方法，那么做法二更适合于后期项目从 rem 单位过渡到 vw 单位。只需要通过改变根元素大小的计算方式，你就可以不需要其他任何的处理，就无缝过渡到另一种CSS单位，更何况vw单位的使用必然会成为一种更好适配方式，目前它只是碍于兼容性的支持而得不到广泛的应用。 后语这是笔者在偶然中阅读到[翻译]使用VH和VW实现真正的流体排版这一篇文章得到的感悟与成果，也满心欢喜地期待这篇文章同样能够带给读者一些启发，并提出一些的vw单位使用秘笈来交流交流～:） 参考文档 基于视口单位的网页排版 (转）基于视口单位的网页排版 [翻译]使用VH和VW实现真正的流体排版","pubDate":"Fri, 28 Apr 2017 02:25:00 GMT","guid":"https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/","category":"Web开发"},{"title":"【译】关于 Node.js 里 ES6 Modules 的一次更新说明","link":"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/","description":"James M Snell IBM Technical Lead for Node.js原文链接: An Update on ES6 Modules in Node.js 几个月前，我写了一篇文章来描述 Node.js 现存的 CommonJS 模块和新的 ES6 模块系统的许多不同，也说明了在 Node.js 内核中实现这个新模型的内在的一些挑战。现在，我想分享一下关于这件事情的进展情况。 明白你什么时候该知道你需要知道的东西在这之前，如果你还没准备好，你可以花一点时间来看一下我之前的描述这两个模块架构上存在许多根本区别的文章。总结来说就是：CommonJS 与 ES6 Modules 之间的关键不同在于代码什么时候知道一个模块的结构和使用它。 举个栗子，假如我现在有一个简单的 CommonJS 模块（模块名叫&#39;foobar&#39;）： 12345678function foo() &#123; return 'bar';&#125;function bar() &#123; return 'foo';&#125;module.exports.foo = foo;module.exports.bar = bar; 现在我们在一个叫 app.js 的 JS 文件中引用它 12const &#123;foo, bar&#125; = require('foobar');console.log(foo(), bar()); 当我执行 $node app.js 的时候，Node.js 已二进制的形式加载 app.js 文件，解析它，并且开始执行里面的代码。在执行过程中，里面的 require() 方法被调用，然后它会同步的去加载 foobar.js 的内容进内存，同步的解析编译里面的 JavaScript 代码，同步的执行里面的代码，然后返回 module.exports 的值当做 app.js 里的 require(&#39;foobar&#39;) 的返回值。当 app.js 里的 require() 方法返回的时候，foobar 模块的结构就已经知道了，并且可以被使用。所有的这些事情都发生在 Node.js 进程事件循环的同一个周期里。 要理解 CommonJS 与 ES6 Modules 之间的不同至关重要的是，一个 CommonJS 的模块在没有被执行完之前，它的结构（API）是不可知的 — 即使在它被执行完以后，它的结构也可以随时被其他代码修改。 现在我们用 ES6 的写法来写同样的模块： 123456export function foo() &#123; return 'bar';&#125;export function bar() &#123; return 'foo';&#125; 并且在代码中引用它： 123import &#123;foo, bar&#125; from 'foobar';console.log(foo());console.log(bar()); 从 ECMAScript 统一的标准来看，ES6 Modules 的步骤与 CommonJS 里已经实现的有很大的不同。第一步从硬盘上加载文件内容大致上是相同的，但是可能是异步的。当内容加载完成后，会解析它。在解析的同时，模块里被 export 声明定义的结构会在组件内容被执行之前就探知出来。一旦结构被探知出来，组件的代码就会被执行。这里重要的是记住所有的 import 和 export 语句都会在代码执行之前被解析出来。另一点是在 ES6 中是允许这个解析的步骤异步执行的。这就意味着，在 Node.js 的机制中，加载脚本内容、解析模块的 import 和 export 、执行模块代码将发生在多个事件循环里。 时机很重要在评估 ES6 Modules 的可实现性之前，我们关注的重点是怎么样无缝衔接的实现它。比如我们希望它可以可以实现同时对两种模块的支持，这样可以很大程度上对用户是透明的。 可惜，事情并不是这么简单… 尤其是 ES6 Modules 的加载、解析和执行都是异步的，这就导致不能通过 require() 来引用一个 ES6 模块。原因是 require() 是一个完全同步的函数。如果我们去修改 require() 的语义让它可以进行异步加载的话，那对于现有的生态系统将会产生巨大的破坏。所以我们有考虑在 ES6 的 import() 函数提议（详情）通过之后建模实现一个 require.import() 函数。这个函数会返回一个 Promise 在 ES6 模块加载完成后标记完成。这不是最好的方案，但是它可以让你在现有的 Node.js 里以 CommonJS 的格式来使用。 有一点好消息是在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块。因为在 ES6 模块里异步加载不是必须的。ECMAScript 规范进行一些小修改就可以更好地支持这种方式。但是所有这些工作过后，还有一个重要的事情… 命名引用命名引用是 ES6 Modules 里的一个基本的特性。举个例子： 1import &#123;foo, bar&#125; from 'foobar'; 变量 foo 和 bar 在解析阶段就从 foobar 中被引用进来 —— 在所有代码被执行之前。因为 ES6 Modules 的结构是之前就可以被探知到的。 另一方面，在 CommonJS 里模块结构在代码没有执行之前是不能被探知的。也就是说，如果不对 ECMAScript 规范做重大更改的话，在 CommonJS 模块里是不能使用命名引用的。开发者会引用到 ES6 Modules 里面的名为 “default” 的导出。比如，上面的例子在 CommonJS 里是这样的： 12import foobar from 'foobar';console.log(foobar.foo(), foobar.bar()); 区别很小但是很重要。所以当你想使用 import 来引用一个 CommonJS 模块的时候，下面这种写法是根本行不通的： 1import &#123;foo, bar&#125; from 'foobar'; 这里的 foo 和 bar 不会直接被解析成 CommonJS 模块里导出的 foo() 和 bar() 方法。 但是在 Babel 里可以！使用过像 Babel 这种的 ES6 Modules 语法转换工具的人应该很熟悉命名引用。Babel 的工作原理是把 ES6 的写法转换成可以在 Node.js 里运行的 CommonJS 的形式。虽然语法看起来很像 ES6，但是实际上并不是。这一点很重要，Babel 里的 ES6 命名引用与完全按照规范实现的 ES6 命名引用有本质的不同。 Michael Jackson Script实际上CommonJS 和 ES6 Modules 之间还有另外一个重要的不同就是，ECMAScript 编译器必须提前知道它加载的代码是 CommonJS 的还是 ES6 Modules 的。原因是之前说的 ES6 Modules 必须在代码执行前就解析出模块中的 import 和 export 声明。 这就意味着 Node.js 需要某些机制来预先识别它在加载那种类型的文件。在探索了很多方案以后，我们回归到了以前最糟糕的方案，就是引入一个新的 *.mjs 文件后缀来表示一个 ES6 Modules 的 JavaScript 文件。（之前我们亲切的叫它 “Michael Jackson Script”） 时间线在目前的时间点上，在 Node.js 可以开始处理支持实现 ES6 Modules 之前，还有很多关于规范现实的问题和虚拟机方面的问题。相关工作还在进行，但是需要一些时间 —— 我们目前估计至少需要一年左右。","pubDate":"Sat, 22 Apr 2017 02:09:24 GMT","guid":"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/","category":"NodeJS"}]}